{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome!","title":"Home"},{"location":"#welcome","text":"","title":"Welcome!"},{"location":"about/","text":"About To be created!","title":"About"},{"location":"about/#about","text":"To be created!","title":"About"},{"location":"Coding%20Interview/Code%20Snippet/Stack%2C%20Queue%2C%20and%20PriorityQueue/","text":"Stack Stack in Java is an old implementation that uses Vector . The modern one we should use is Deque < Integer > stack = new LinkedList <> (); stack . push ( 1 ); int value = stack . pop (); int peekValue = stack . peek (); This is easier to remember than addFirst(e) , removeFirst() , and peekFirst() Queue The good thing of Java's implementation is LinkedList can be used as both stack and queue. Queue < Integer > queue = new LinkedList <> (); Also, even better, Deque is sub interface of Queue so Deque actually has all queue operations as well as stack. Deque < Integer > queue = new LinkedList <> (); queue . add ( 1 ); int value = queue . remove (); int peekValue = queue . peek (); In summary, we can use LinkedList with Deque interface as a stack or a queue. Stack stack.push(element) stack.pop() stack.peek() Queue queue.add(element) queue.remove() queue.peek() PriorityQueue If we can skip Heap implementation, let's use PriorityQueue It can be created from other collections like PriorityQueue < Integer > heap = new PriorityQueue <> ( Collection c ); PriorityQueue < Integer > heap = new PriorityQueue <> ( PriorityQueue c ); PriorityQueue < Integer > heap = new PriorityQueue <> ( SortedSet c ); Default sorting is natural ordering . In case we want custom or reverse order PriorityQueue < Integer > heap = new PriorityQueue <> ( Comparator c ); // For example PriorityQueue < Integer > maxHeap = new PriorityQueue <> ( Comparator . reverseOrder ()); PriorityQueue < Integer > maxHeap = new PriorityQueue <> (( a , b ) -> b - a ); PriorityQueue < Integer > maxHeap = new PriorityQueue <> (( a , b ) -> b . compareTo ( a ); Operations heap.add(element) heap.poll() heap.peek()","title":"Stack, Queue, and PriorityQueue"},{"location":"Coding%20Interview/Code%20Snippet/Stack%2C%20Queue%2C%20and%20PriorityQueue/#stack","text":"Stack in Java is an old implementation that uses Vector . The modern one we should use is Deque < Integer > stack = new LinkedList <> (); stack . push ( 1 ); int value = stack . pop (); int peekValue = stack . peek (); This is easier to remember than addFirst(e) , removeFirst() , and peekFirst()","title":"Stack"},{"location":"Coding%20Interview/Code%20Snippet/Stack%2C%20Queue%2C%20and%20PriorityQueue/#queue","text":"The good thing of Java's implementation is LinkedList can be used as both stack and queue. Queue < Integer > queue = new LinkedList <> (); Also, even better, Deque is sub interface of Queue so Deque actually has all queue operations as well as stack. Deque < Integer > queue = new LinkedList <> (); queue . add ( 1 ); int value = queue . remove (); int peekValue = queue . peek (); In summary, we can use LinkedList with Deque interface as a stack or a queue. Stack stack.push(element) stack.pop() stack.peek() Queue queue.add(element) queue.remove() queue.peek()","title":"Queue"},{"location":"Coding%20Interview/Code%20Snippet/Stack%2C%20Queue%2C%20and%20PriorityQueue/#priorityqueue","text":"If we can skip Heap implementation, let's use PriorityQueue It can be created from other collections like PriorityQueue < Integer > heap = new PriorityQueue <> ( Collection c ); PriorityQueue < Integer > heap = new PriorityQueue <> ( PriorityQueue c ); PriorityQueue < Integer > heap = new PriorityQueue <> ( SortedSet c ); Default sorting is natural ordering . In case we want custom or reverse order PriorityQueue < Integer > heap = new PriorityQueue <> ( Comparator c ); // For example PriorityQueue < Integer > maxHeap = new PriorityQueue <> ( Comparator . reverseOrder ()); PriorityQueue < Integer > maxHeap = new PriorityQueue <> (( a , b ) -> b - a ); PriorityQueue < Integer > maxHeap = new PriorityQueue <> (( a , b ) -> b . compareTo ( a ); Operations heap.add(element) heap.poll() heap.peek()","title":"PriorityQueue"},{"location":"Coding%20Interview/Patterns/01.%20Array%20and%20Hashing/","text":"Use HashMap or HashSet to count/remember elements 217. Contains Duplicate 242. Valid Anagram While collecting data, we can calculate/check the element as well 1. Two Sum Smart way to hash Use char[] hash that count frequency as hash string: 49. Group Anagrams Use string concat to create meaningful hash: 36. Valid Sudoku Use string length + separator to seperate words: 271. Encode and Decode Strings or 659 \u00b7 Encode and Decode Strings Multiple iterations Forward and backward: 238. Product of Array Except Self Use hashing with determistic sequence to search data: 128. Longest Consecutive Sequence","title":"01. Array and Hashing"},{"location":"Coding%20Interview/Patterns/02.%20Two%20Pointers/","text":"One forward, the other backward Move 2 pointers to meet the condition in the same loop Move the pointer to point to the letter - 125. Valid Palindrome Move left pointer to increase sum; move right pointer to decrease sum - 167. Two Sum II - Input Array Is Sorted Sort data first would help running pointer more meaningful 15. 3Sum - Sort data, for each element search the other 2 using 2 pointers, skip duplicate for better performance Getting max value along the way 11. Container With Most Water - Keep calculating amount of water from outside to inside, move the pointer with shorter value inside, update max value 42. Trapping Rain Water - Keep track of max left and right, the water amount added = max - current on the smaller size, move the pointer on the smaller size.","title":"02. Two Pointers"},{"location":"Coding%20Interview/Patterns/03.%20Sliding%20Window/","text":"Left and Right pointer go same direction 121. Best Time to Buy and Sell Stock Left = buy date, Right = sell date; right = left + 1 Price right > price left i.e. profit > 0 -> update max profit Otherwise, move left to right as now right will be the best buy date Right++ 567. Permutation in String Problem is to check if s2 contains permutation of s1 or not Create 'signature' using frequency from s1. int[26] is good Create 'signature' from string length = s1 from s2 assuming that s2 is longer Start from left = 0, right = s1.length(), create signature and compare Keep moving left and right, create signature, if match return true; otherwise, return false; Set a rule of where the left/right is and move one to make condition true 3. Longest Substring Without Repeating Characters The rule is Left/Right = beginning/end of unique char; start both at 0 Typically, move right til the end If moving right doesn't break the condition i.e. see unseen char, keep moving If moving right break the condition i.e. see seen char, Need to fix it by moving left Move left until seeing the char that right see and plus 1 to make the string from left to right unique Calculate max when moving right where the length increase 424. Longest Repeating Character Replacement The rule is Left/Right = beginning/end of char that can be replaced within k times The calculation is length = right - left + 1 length - max frequency char <= k then it's good Add right count first if the condition is valid keep moving right Otherwise, move left until it's valid Keep track of count; increase freq when moving right, decrease freq when moving left There is a tricky way not to use max freq of all char. Using max so far works too. 76. Minimum Window Substring Returns minimum substring of s that has all chars in t The rule is Left/Right = beginning/end of the substring that covers all chars in t Keep moving right until the substring covers t Then, shrink left until the substring doesn't cover t Calculate minLength along the way The substring trick is to Count freq of t in int[256] (lower/uppercases) Right move -> decrease the count (char in s that is not in t will be < 0) Left move -> increase the count (char in s that is not in t will never be > 0) Have int match to keep counting how manay chars matches: increase/decrease only if count > 0 It may come with usage of other data structure ... 239. Sliding Window Maximum Given and array of int and k as int, return max of value of the sliding window k The sliding window here is obvious as just shifting left/right to be size k along the input array The issue is how to get the max value of the window. The most intuitive one is to use max heap. But, we need heap size k and k can be really large The trick is to use monotonic decreasing queue where the head is the max value and the subsequent elements will be less When adding, remove all elements that is less than the number to be added When removing, remove if the head of the queue = the number at the left index Keep collecting the answer at the head of the queue","title":"03. Sliding Window"},{"location":"Coding%20Interview/Patterns/04.%20Stack/","text":"Basic Stack usage 20. Valid Parentheses 150. Evaluate Reverse Polish Notation FIFO property can be helpful 155. Min Stack Implement a stack that can also return min value The trick is the top value saw all the elements in the past so attaching min value so far with the element help returning min at O(n) Monotonic Stack 739. Daily Temperatures Given an array of temperatures, return number of days have to wait for warmer temperatures Use monotonic stack to keep track of position i Add data backward, pop the day that has lower or equal temperature. So, the bottom of the stack is the warmest day The diff of the index will be the number of wait days 853. Car Fleet Given an array of positions and speeds of cars and target distance, return the number of car fleet. The rule is if one car reach the other in front, they will merge into one. The fleet's speed will be the one in front i.e. the slower one To know if cars will be merged or not, we need to calculate time each car reaching the destination. Faster car has lower amount of time Also, we need to sort the car by position Use the monotonic stack to kee track of time. The car that has lower time i.e. faster car will be removed as it will be merged with the slower one The result will be the size of the stack 84. Largest Rectangle in Histogram Given an array of heights of histogram, returns the largest rectangle If the height of the current bar is lower than the previous, the current bar will block the size of the rectangle Use the stack to keep track of increasing heights only. Pop out all the one that are taller than the current one The logic to calculate rectangle could be complicated. Need to read the solution again.","title":"04. Stack"},{"location":"Coding%20Interview/Patterns/05.%20Binary%20Search/","text":"Basic binary search Remember the loop while ( start <= end ) { int mid = start + ( end - start ) / 2 ; // mid at size/2 round down if ( nums [ mid ] == target ) return mid ; if ( nums [ mid ] < target ) start = mid + 1 ; else end = mid - 1 ; } 704. Binary Search 74. Search a 2D Matrix Items sorted and arranged in 2D matrix Stretch it out as 1D by having a formula to map mid point to row/col It can help brute forcing solution 875. Koko Eating Bananas Given a array of banana pile and h as no. of hour til guard is back, return mininum no. of banana per hour k that Koko can eat all the piles before the guard is back The slowest speed is 1 per hour The fastest speed is the max of banana pile i.e. Koko will spend time eating equal to number of piles We keep searching for the slowest speed Have a function to calculate hour spent if Koko eat at k speed Use binary search to scope the speed down Fancy ways to cut data in half 153. Find Minimum in Rotated Sorted Array Given a sorted array that was rotated, return the min number The trick is how to know which side to keep left or right? If the 'crack' is on the left i.e. mid < right, search left -> mid If the 'crack' is on the right i.e. mid > right, search mid + 1 -> right Search until left == right i.e. the bottom of the crack 33. Search in Rotated Sorted Array Given a sorted array that was rotated, search index of the target value using binary search The trick is how to know which side to keep left or right? Same as above If 'crack' is on the left i.e. mid < right If mid < target < right i.e. target is in the slope from mid to right -> search mid+1 -> right Else i.e. target is in the crack side -> search left -> mid-1 If 'crack' is on the right i.e. mid > right If left < target < mid i.e. target is in the slop from left to mid -> search left -> mid-1 Else i.e. target is in the crack side -> search mid+1 -> right 658. Find K Closest Elements Given a sorted array arr[] , returns a subarray size k that minimum sum of the 'distance' to x i.e. |arr[i] - x| For example Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4] The trick is to use binary search to adjust the window If the distance of mid > the distance of mid+k -> left = mid+1; Else -> right = mid The answer is array from arr[left] - arr[left+k]","title":"05. Binary Search"},{"location":"Coding%20Interview/Patterns/10.%20Backtracking/","text":"22. Generate Parentheses","title":"10. Backtracking"},{"location":"Coding%20Interview/Patterns/14.%20Interval/","text":"Check overlapping intervals Use negative logic is easier to understand 2 intervals are NOT overlapping if End of the first < Start of the second <--1--> <--2--> OR End of the second < Start of the first <--2--> <--1--> So 2 intervals are touching/overlapping if the above condition is not true boolean overlapping ( Interval interval1 , Interval interval2 ) { return ! ( interval1 . start () < interval2 . end () || interval2 . start () < interval1 . end ()); } Sorted intervals by start time helps a lot 57. Insert Interval Given intervals sorted by start time and a new interval to insert, insert the new interval and merge with the existing one There are 3 possible sections Intervals that are not overlapping with the new interval and the start time is before Intervals that are overlapping with the new interval Intervals that are not overlapping with the new interval and the start time is after Best to deal with them in 3 section separately The first section, add the interval to the answer list directly until the interval is overlapping The second section, keep merging until the interval is not overlapping; then add the merge result to the answer list The last section, add the interval to the answer list directly until the end of the data Be careful the edge case where the interval array is empty but the new interval is not","title":"14. Interval"},{"location":"Coding%20Interview/Problems/HR/plus_minus/","text":"Plus Minus Problem Given an array of integers, calculate the ratios of its elements that are positive, negative, and zero. Print the decimal value of each fraction on a new line with 6 places after the decimal. Solution The calculation is simple. The key is to format the number correctly. As all of us know, double/float in Java can be weird. Solution 1: Use printf formatting Calculate the percentage normall and use printf formatting to format the number. This is probably the most straightforward way to solve this problem public static void plusMinus ( List < Integer > arr ) { double p = 0 , n = 0 , z = 0 ; for ( int i : arr ) { if ( i == 0 ) z ++ ; else if ( i < 0 ) n ++ ; else if ( i > 0 ) p ++ ; } System . out . printf ( \"%8.6f\\n\" , p / arr . size ()); System . out . printf ( \"%8.6f\\n\" , n / arr . size ()); System . out . printf ( \"%8.6f\\n\" , z / arr . size ()); } Solution 2: Use BigDecimal We can use BigDecimal to do calculation with speficy precision. This is probably a bit overkill for interview solution. But, use BigDecimal is a good practice if your appliation is related to cost or money where it has a specific way to round the number. Note that when dividing numbers using BigDecimal, we should always set scale otherwise it can throws ArithmeticException as by default it will try to return exact precision. public static void plusMinus ( List < Integer > arr ) { int p = 0 , n = 0 , z = 0 ; for ( int i : arr ) { if ( i == 0 ) z ++ ; else if ( i < 0 ) n ++ ; else if ( i > 0 ) p ++ ; } BigDecimal size = BigDecimal . valueOf ( arr . size ()); System . out . println ( BigDecimal . valueOf ( p ). divide ( size , 6 , RoundingMode . HALF_UP )); System . out . println ( BigDecimal . valueOf ( n ). divide ( size , 6 , RoundingMode . HALF_UP )); System . out . println ( BigDecimal . valueOf ( z ). divide ( size , 6 , RoundingMode . HALF_UP )); }","title":"Plus Minus"},{"location":"Coding%20Interview/Problems/HR/plus_minus/#plus-minus","text":"","title":"Plus Minus"},{"location":"Coding%20Interview/Problems/HR/plus_minus/#problem","text":"Given an array of integers, calculate the ratios of its elements that are positive, negative, and zero. Print the decimal value of each fraction on a new line with 6 places after the decimal.","title":"Problem"},{"location":"Coding%20Interview/Problems/HR/plus_minus/#solution","text":"The calculation is simple. The key is to format the number correctly. As all of us know, double/float in Java can be weird.","title":"Solution"},{"location":"Coding%20Interview/Problems/HR/plus_minus/#solution-1-use-printf-formatting","text":"Calculate the percentage normall and use printf formatting to format the number. This is probably the most straightforward way to solve this problem public static void plusMinus ( List < Integer > arr ) { double p = 0 , n = 0 , z = 0 ; for ( int i : arr ) { if ( i == 0 ) z ++ ; else if ( i < 0 ) n ++ ; else if ( i > 0 ) p ++ ; } System . out . printf ( \"%8.6f\\n\" , p / arr . size ()); System . out . printf ( \"%8.6f\\n\" , n / arr . size ()); System . out . printf ( \"%8.6f\\n\" , z / arr . size ()); }","title":"Solution 1: Use printf formatting"},{"location":"Coding%20Interview/Problems/HR/plus_minus/#solution-2-use-bigdecimal","text":"We can use BigDecimal to do calculation with speficy precision. This is probably a bit overkill for interview solution. But, use BigDecimal is a good practice if your appliation is related to cost or money where it has a specific way to round the number. Note that when dividing numbers using BigDecimal, we should always set scale otherwise it can throws ArithmeticException as by default it will try to return exact precision. public static void plusMinus ( List < Integer > arr ) { int p = 0 , n = 0 , z = 0 ; for ( int i : arr ) { if ( i == 0 ) z ++ ; else if ( i < 0 ) n ++ ; else if ( i > 0 ) p ++ ; } BigDecimal size = BigDecimal . valueOf ( arr . size ()); System . out . println ( BigDecimal . valueOf ( p ). divide ( size , 6 , RoundingMode . HALF_UP )); System . out . println ( BigDecimal . valueOf ( n ). divide ( size , 6 , RoundingMode . HALF_UP )); System . out . println ( BigDecimal . valueOf ( z ). divide ( size , 6 , RoundingMode . HALF_UP )); }","title":"Solution 2: Use BigDecimal"},{"location":"Coding%20Interview/Problems/LeetCode/0001.%20Two%20Sum/","text":"Problem Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. class Solution { public int [] twoSum ( int [] nums , int target ) { } } You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? Approaches Brute force approach For nums[i] , go through all other elements nums[j] if nums[i] + nums[j] == target This is O(n^2) solution Idea improve - We want to find target - nums[i] value quickly - We can use Set or Map to collect data so checking if target - nums[i] exists can be O(n). This will make the whole solution O(n) - Simple approach is to - Go through nums to collect data with position in a Map - Go through nums again to find the match from the Map previously created - However, we could go through nums in one go by checking the target then add to the Map index i nums[] = { <nums already saved in Map>, X, <nums not parsing yet>} if target - X is in the Map return { position of 'target - X', i} else Map.put(X, i) Solution class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < nums . length ; i ++ ) { Integer pos = map . get ( target - nums [ i ] ); if ( pos != null ) { return new int [] { pos , i }; } map . put ( nums [ i ] , i ); } // This shouldn't happen return null ; } }","title":"0001. Two Sum"},{"location":"Coding%20Interview/Problems/LeetCode/0001.%20Two%20Sum/#problem","text":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. class Solution { public int [] twoSum ( int [] nums , int target ) { } } You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0001.%20Two%20Sum/#approaches","text":"Brute force approach For nums[i] , go through all other elements nums[j] if nums[i] + nums[j] == target This is O(n^2) solution Idea improve - We want to find target - nums[i] value quickly - We can use Set or Map to collect data so checking if target - nums[i] exists can be O(n). This will make the whole solution O(n) - Simple approach is to - Go through nums to collect data with position in a Map - Go through nums again to find the match from the Map previously created - However, we could go through nums in one go by checking the target then add to the Map index i nums[] = { <nums already saved in Map>, X, <nums not parsing yet>} if target - X is in the Map return { position of 'target - X', i} else Map.put(X, i)","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0001.%20Two%20Sum/#solution","text":"class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < nums . length ; i ++ ) { Integer pos = map . get ( target - nums [ i ] ); if ( pos != null ) { return new int [] { pos , i }; } map . put ( nums [ i ] , i ); } // This shouldn't happen return null ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0015.%203Sum/","text":"Problem Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j , i != k , and j != k , and nums[i] + nums[j] + nums[k] == 0 . Notice that the solution set must not contain duplicate triplets. Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Example 2: Input: nums = [] Output: [] Example 3: Input: nums = [0] Output: [] Constraints: 0 <= nums.length <= 3000 -10^5 <= nums[i] <= 10^5 Approaches Brute force approach would be O(n^3) as we search for i , j , and k from n elements Breaking the problem using 2 sum solution DOES NOT work This question needs value, not index This question needs unique set of values The approach is to sort the number first. This would help finding target number easier Once we have sorted nums[] , for nums[i] , we have 2 pointers j starts at i+1 and k starts at nums.length-1 Then, we will check if nums[i] + nums[j] + nums[k] is equal to 0 or not If so, we save the 3 values in the result bucket and move both pointer; move j forward and move k backward If the sum is > 0, we move k backward only to reduce the sum If the sum is < 0, we move j forward only to reduce the sum Continue until j reaches k i.e. j >= k The test cases in LC has a lot of duplicate. So we can shorten run time by skipping the loop when nums[i] has been already considered i.e. nums[i] == nums[i-1] Similary, when moving j or k , if we already consider the same values i.e. nums[j] == nums[j-1] or nums[k] == nums[k+1] Solution class Solution { public List < List < Integer >> threeSum ( int [] nums ) { Set < List < Integer >> result = new HashSet <> (); Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length - 2 ; i ++ ) { // Skip dup i if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; int j = i + 1 ; int k = nums . length - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ] ; if ( sum == 0 ) { result . add ( Arrays . asList ( nums [ i ] , nums [ j ++] , nums [ k --] )); // Skip dup j and k while ( j < k && nums [ j ] == nums [ j - 1 ] ) j ++ ; while ( j < k && nums [ k ] == nums [ k + 1 ] ) k -- ; } else if ( sum > 0 ) { k -- ; // Skip dup k while ( j < k && nums [ k ] == nums [ k + 1 ] ) k -- ; } else { j ++ ; // Skip dup j while ( j < k && nums [ j ] == nums [ j - 1 ] ) j ++ ; } } } return new ArrayList <> ( result ); } }","title":"0015. 3Sum"},{"location":"Coding%20Interview/Problems/LeetCode/0015.%203Sum/#problem","text":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j , i != k , and j != k , and nums[i] + nums[j] + nums[k] == 0 . Notice that the solution set must not contain duplicate triplets. Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Example 2: Input: nums = [] Output: [] Example 3: Input: nums = [0] Output: [] Constraints: 0 <= nums.length <= 3000 -10^5 <= nums[i] <= 10^5","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0015.%203Sum/#approaches","text":"Brute force approach would be O(n^3) as we search for i , j , and k from n elements Breaking the problem using 2 sum solution DOES NOT work This question needs value, not index This question needs unique set of values The approach is to sort the number first. This would help finding target number easier Once we have sorted nums[] , for nums[i] , we have 2 pointers j starts at i+1 and k starts at nums.length-1 Then, we will check if nums[i] + nums[j] + nums[k] is equal to 0 or not If so, we save the 3 values in the result bucket and move both pointer; move j forward and move k backward If the sum is > 0, we move k backward only to reduce the sum If the sum is < 0, we move j forward only to reduce the sum Continue until j reaches k i.e. j >= k The test cases in LC has a lot of duplicate. So we can shorten run time by skipping the loop when nums[i] has been already considered i.e. nums[i] == nums[i-1] Similary, when moving j or k , if we already consider the same values i.e. nums[j] == nums[j-1] or nums[k] == nums[k+1]","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0015.%203Sum/#solution","text":"class Solution { public List < List < Integer >> threeSum ( int [] nums ) { Set < List < Integer >> result = new HashSet <> (); Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length - 2 ; i ++ ) { // Skip dup i if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; int j = i + 1 ; int k = nums . length - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ] ; if ( sum == 0 ) { result . add ( Arrays . asList ( nums [ i ] , nums [ j ++] , nums [ k --] )); // Skip dup j and k while ( j < k && nums [ j ] == nums [ j - 1 ] ) j ++ ; while ( j < k && nums [ k ] == nums [ k + 1 ] ) k -- ; } else if ( sum > 0 ) { k -- ; // Skip dup k while ( j < k && nums [ k ] == nums [ k + 1 ] ) k -- ; } else { j ++ ; // Skip dup j while ( j < k && nums [ j ] == nums [ j - 1 ] ) j ++ ; } } } return new ArrayList <> ( result ); } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0020.%20Valid%20Parentheses/","text":"Problem Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1: Input: s = \"()\" Output: true Example 2: Input: s = \"()[]{}\" Output: true Example 3: Input: s = \"(]\" Output: false Approaches This is classic usage of Stack Go through each char of the input. If the char is one of the 'open' brackets, push it to the stack If the char is out of the 'close' brackets, pop a char from the stack If they don't match, return false Solution class Solution { public boolean isValid(String s) { Deque stack = new LinkedList<>(); for (char c : s.toCharArray()) { if (open(c)) { stack.push(c); } else if (close(c)) { if (stack.isEmpty() || !match(stack.pop(), c)) { return false; } } } return stack.isEmpty(); } public boolean open(char c) { return c == '(' || c == '[' || c == '{'; } public boolean close(char c) { return c == ')' || c == ']' || c == '}'; } public boolean match(char open, char close) { return (open == '(' && close == ')') || (open == '[' && close == ']') || (open == '{' && close == '}'); } }","title":"0020. Valid Parentheses"},{"location":"Coding%20Interview/Problems/LeetCode/0020.%20Valid%20Parentheses/#problem","text":"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1: Input: s = \"()\" Output: true Example 2: Input: s = \"()[]{}\" Output: true Example 3: Input: s = \"(]\" Output: false","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0020.%20Valid%20Parentheses/#approaches","text":"This is classic usage of Stack Go through each char of the input. If the char is one of the 'open' brackets, push it to the stack If the char is out of the 'close' brackets, pop a char from the stack If they don't match, return false","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0020.%20Valid%20Parentheses/#solution","text":"class Solution { public boolean isValid(String s) { Deque stack = new LinkedList<>(); for (char c : s.toCharArray()) { if (open(c)) { stack.push(c); } else if (close(c)) { if (stack.isEmpty() || !match(stack.pop(), c)) { return false; } } } return stack.isEmpty(); } public boolean open(char c) { return c == '(' || c == '[' || c == '{'; } public boolean close(char c) { return c == ')' || c == ']' || c == '}'; } public boolean match(char open, char close) { return (open == '(' && close == ')') || (open == '[' && close == ']') || (open == '{' && close == '}'); } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0031.%20Next%20Permutation/","text":"Problem A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2]. Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. Example 1: Input: nums = [1,2,3] Output: [1,3,2] Example 2: Input: nums = [3,2,1] Output: [1,2,3] Example 3: Input: nums = [1,1,5] Output: [1,5,1] Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 100","title":"0031. Next Permutation"},{"location":"Coding%20Interview/Problems/LeetCode/0031.%20Next%20Permutation/#problem","text":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2]. Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. Example 1: Input: nums = [1,2,3] Output: [1,3,2] Example 2: Input: nums = [3,2,1] Output: [1,2,3] Example 3: Input: nums = [1,1,5] Output: [1,5,1] Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 100","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0049.%20Group%20Anagrams/","text":"Problem Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] Example 2: Input: strs = [\"\"] Output: [[\"\"]] Example 3: Input: strs = [\"a\"] Output: [[\"a\"]] Constraints: 1 <= strs.length <= 10^4 0 <= strs[i].length <= 100 strs[i] consists of lowercase English letters. Approach Words can be grouped together if they have same char frequency Another idea is they are equal after sorted How can we find the 'hashcode' of each word easily? 2 approaches Since words consits of lowercase only, we can do counting sort so it will be O(n) not O(n log n) . The sorted word will be the 'hashcode' Use frequency saved in char[26] and convert this array to String as the hashcode Solution // Counting sort class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { Map < String , List < String >> groups = new HashMap <> (); for ( String s : strs ) { String sortedString = sort ( s ); groups . computeIfAbsent ( sortedString , k -> new ArrayList <> ()). add ( s ); } return new ArrayList <> ( groups . values ()); } public String sort ( String word ) { int [] chars = new int [ 26 ] ; for ( char c : word . toCharArray ()) { chars [ c - 'a' ]++ ; } StringBuffer sb = new StringBuffer (); for ( int i = 0 ; i < chars . length ; i ++ ) { for ( int j = 0 ; j < chars [ i ] ; j ++ ) { sb . append (( char ) ( 'a' + i )); } } return sb . toString (); } } // Use char[] as hash class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { Map < String , List < String >> groups = new HashMap <> (); for ( String s : strs ) { String hashCode = hash ( s ); groups . computeIfAbsent ( hashCode , k -> new ArrayList <> ()). add ( s ); } return groups . values (). stream (). collect ( Collectors . toList ()); } public String hash ( String word ) { char [] hash = new char [ 26 ] ; for ( char c : word . toCharArray ()) { hash [ c - 'a' ]++ ; } return new String ( hash ); } }","title":"0049. Group Anagrams"},{"location":"Coding%20Interview/Problems/LeetCode/0049.%20Group%20Anagrams/#problem","text":"Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] Example 2: Input: strs = [\"\"] Output: [[\"\"]] Example 3: Input: strs = [\"a\"] Output: [[\"a\"]] Constraints: 1 <= strs.length <= 10^4 0 <= strs[i].length <= 100 strs[i] consists of lowercase English letters.","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0049.%20Group%20Anagrams/#approach","text":"Words can be grouped together if they have same char frequency Another idea is they are equal after sorted How can we find the 'hashcode' of each word easily? 2 approaches Since words consits of lowercase only, we can do counting sort so it will be O(n) not O(n log n) . The sorted word will be the 'hashcode' Use frequency saved in char[26] and convert this array to String as the hashcode","title":"Approach"},{"location":"Coding%20Interview/Problems/LeetCode/0049.%20Group%20Anagrams/#solution","text":"// Counting sort class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { Map < String , List < String >> groups = new HashMap <> (); for ( String s : strs ) { String sortedString = sort ( s ); groups . computeIfAbsent ( sortedString , k -> new ArrayList <> ()). add ( s ); } return new ArrayList <> ( groups . values ()); } public String sort ( String word ) { int [] chars = new int [ 26 ] ; for ( char c : word . toCharArray ()) { chars [ c - 'a' ]++ ; } StringBuffer sb = new StringBuffer (); for ( int i = 0 ; i < chars . length ; i ++ ) { for ( int j = 0 ; j < chars [ i ] ; j ++ ) { sb . append (( char ) ( 'a' + i )); } } return sb . toString (); } } // Use char[] as hash class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { Map < String , List < String >> groups = new HashMap <> (); for ( String s : strs ) { String hashCode = hash ( s ); groups . computeIfAbsent ( hashCode , k -> new ArrayList <> ()). add ( s ); } return groups . values (). stream (). collect ( Collectors . toList ()); } public String hash ( String word ) { char [] hash = new char [ 26 ] ; for ( char c : word . toCharArray ()) { hash [ c - 'a' ]++ ; } return new String ( hash ); } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0053.%20Maximum%20Subarray/","text":"Problem Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. Example 1: Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: Input: nums = [1] Output: 1 Example 3: Input: nums = [5,4,-1,7,8] Output: 23 Constraints: 1 <= nums.length <= 10^5 -10^4 <= nums[i] <= 10^4 Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Approaches This can be really headache to think than it should be Imagine we have a 'chain' of numbers that can be summed to a number. When should we include nums[i] in the chain? When the previous change + nums[i] is better We can use dynamic programming approach. Let dp[i] is the max sequence til nums[i] dp[i] is the max of dp[i-1] -> nums[i] is not included max sequence ends at i-1 + nums[i] -> nums[i] is included with the adjacent sequence nums[i] -> nums[i] over power the previously found so far We can pull the last 2 which is the problem of finding the 'max sequence end at i ' as the main problem itself and the total max can be just the max of sequenc ends at i for all i So, finally, we can let dp[i] is the max sequence that ends at index i for all i dp[i] is max between dp[i-1] + nums[i] and nums[i] answer is the max of all dp[i] Since DP here is using just previous value so we don't need a full array for this Solution class Solution { public int maxSubArray(int[] nums) { int result = Integer.MIN_VALUE; int dp = 0; for (int n : nums) { dp = Math.max(dp + n, n); result = Math.max(result, dp); } return result; } }","title":"0053. Maximum Subarray"},{"location":"Coding%20Interview/Problems/LeetCode/0053.%20Maximum%20Subarray/#problem","text":"Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. Example 1: Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: Input: nums = [1] Output: 1 Example 3: Input: nums = [5,4,-1,7,8] Output: 23 Constraints: 1 <= nums.length <= 10^5 -10^4 <= nums[i] <= 10^4 Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0053.%20Maximum%20Subarray/#approaches","text":"This can be really headache to think than it should be Imagine we have a 'chain' of numbers that can be summed to a number. When should we include nums[i] in the chain? When the previous change + nums[i] is better We can use dynamic programming approach. Let dp[i] is the max sequence til nums[i] dp[i] is the max of dp[i-1] -> nums[i] is not included max sequence ends at i-1 + nums[i] -> nums[i] is included with the adjacent sequence nums[i] -> nums[i] over power the previously found so far We can pull the last 2 which is the problem of finding the 'max sequence end at i ' as the main problem itself and the total max can be just the max of sequenc ends at i for all i So, finally, we can let dp[i] is the max sequence that ends at index i for all i dp[i] is max between dp[i-1] + nums[i] and nums[i] answer is the max of all dp[i] Since DP here is using just previous value so we don't need a full array for this","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0053.%20Maximum%20Subarray/#solution","text":"class Solution { public int maxSubArray(int[] nums) { int result = Integer.MIN_VALUE; int dp = 0; for (int n : nums) { dp = Math.max(dp + n, n); result = Math.max(result, dp); } return result; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/","text":"Problem You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 <= prices.length <= 105 0 <= prices[i] <= 104 Approaches The max profit would be from \"somewhat\" min and max price day We can only gain the profit only if the min is on the day before the max Brute force solution Pick a buy date i from 0 -> n - 2 . Last day can't be buy date. Let's j is a date after i i.e. from i+1 -> n-1 . Calculate and get max of prices[j] - price[i] O(n^2) Where to optimize? Consider DP approach where DP(i) = max profit of day i Max profit of day i can be either The max profit of day i-1 i.e. the price at day i is not high enough to create new max profit OR ... the price at day i can create new max profit i.e. prices[i] - min price so far > current max profit If we go left to right, the history that matters is The min price as this is the 'best' buy date The max profit as to keep track of the answer This way we can go through the prices only once Solution class Solution { public int maxProfit ( int [] prices ) { int min = Integer . MAX_VALUE ; int maxProfit = 0 ; for ( int p : prices ) { maxProfit = Math . max ( maxProfit , p - min ); min = Math . min ( min , p ); } return maxProfit ; } }","title":"0121. Best Time to Buy and Sell Stock"},{"location":"Coding%20Interview/Problems/LeetCode/0121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#problem","text":"You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 <= prices.length <= 105 0 <= prices[i] <= 104","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#approaches","text":"The max profit would be from \"somewhat\" min and max price day We can only gain the profit only if the min is on the day before the max Brute force solution Pick a buy date i from 0 -> n - 2 . Last day can't be buy date. Let's j is a date after i i.e. from i+1 -> n-1 . Calculate and get max of prices[j] - price[i] O(n^2) Where to optimize? Consider DP approach where DP(i) = max profit of day i Max profit of day i can be either The max profit of day i-1 i.e. the price at day i is not high enough to create new max profit OR ... the price at day i can create new max profit i.e. prices[i] - min price so far > current max profit If we go left to right, the history that matters is The min price as this is the 'best' buy date The max profit as to keep track of the answer This way we can go through the prices only once","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#solution","text":"class Solution { public int maxProfit ( int [] prices ) { int min = Integer . MAX_VALUE ; int maxProfit = 0 ; for ( int p : prices ) { maxProfit = Math . max ( maxProfit , p - min ); min = Math . min ( min , p ); } return maxProfit ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0128.%20Longest%20Consecutive%20Sequence/","text":"Problem Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 Constraints: 0 <= nums.length <= 10^5 -10^9 <= nums[i] <= 10^9 Approach Union Find The ask is to have O(n) run time so this is going to be parsing through the array The number in the consecutive sequence can be in any order. So to answer if adding number nums[i] would increase any previos sequence or not we need to store pretty much all the sequence so far. The previous sequence could be as short as 1 so using DP to save something like 'max so far' would not work here The problem her is like a grouping. See < seq 1> <--- seq 2 ---> ... <--- seq n ---> Adding X, would X 1) Join any existing sequence? 1.1) If so, does X join 2 sequences to be 1 single sequence? 2) Or, X can't join any sequence and create a new one? - Naively we could save 'ranges' of the sequences so far and check if X can join any of them or not - A better way is to use 'Union Find' to join them together - The algorithm is following - Create a Map<Integer, Integer> that maps num to parent - For nums[i] , create a new entry and make the number as its own parent - If there is nums[i] - 1 or nums[i]+1 in the map, update their parent to be nums[i] - This will join the 'tree' of consecutive number together using the latest number as new root Counting The previous approach is generic in the sense that it can be used to group any thing Since this problem can be grouped by consecutive number, we can just rely on math to find/connect groups We can have a Map<Integer, Boolean> to track what number we seen has been already count For nums[i] , we count forward and backward. We flip the flag when counting so we don't count them again. Note that I thought of using Set instead but removing element from a Set while iterating can cause an exception Solution // Basic Union Find class Solution { public int longestConsecutive ( int [] nums ) { Map < Integer , Integer > map = new HashMap <> (); for ( int n : nums ) { map . put ( n , n ); if ( map . containsKey ( n - 1 )) { int root = findRoot ( n - 1 , map ); map . put ( root , n ); } if ( map . containsKey ( n + 1 )) { int root = findRoot ( n - 1 , map ); map . put ( root , n ); } } Map < Integer , Integer > count = new HashMap <> (); int result = Integer . MIN_VALUE ; for ( int n : map . keySet ()) { int root = findRoot ( n , map ); int countSoFar = count . getOrDefault ( root , 0 ) + 1 ; count . put ( root , countSoFar ); result = Math . max ( result , countSoFar ); } return result ; } public int findRoot ( int n , Map < Integer , Integer > map ) { int root = map . get ( n ); while ( root != n ) { root = map . get ( n ); } return root ; } } // Counting class Solution { public int longestConsecutive ( int [] nums ) { if ( nums . length < 2 ) return nums . length ; Map < Integer , Boolean > map = new HashMap <> (); for ( int n : nums ) { if ( map . containsKey ( n )) continue ; map . put ( n , false ); } int max = Integer . MIN_VALUE ; for ( int n : nums ) { if ( map . get ( n )) continue ; map . put ( n , true ); int count = 1 ; int i = n - 1 ; while ( map . containsKey ( i )) { map . put ( i , true ); i -- ; count ++ ; } i = n + 1 ; while ( map . containsKey ( i )) { map . put ( i , true ); i ++ ; count ++ ; } max = Math . max ( max , count ); } return max ; } }","title":"0128. Longest Consecutive Sequence"},{"location":"Coding%20Interview/Problems/LeetCode/0128.%20Longest%20Consecutive%20Sequence/#problem","text":"Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 Constraints: 0 <= nums.length <= 10^5 -10^9 <= nums[i] <= 10^9","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0128.%20Longest%20Consecutive%20Sequence/#approach","text":"","title":"Approach"},{"location":"Coding%20Interview/Problems/LeetCode/0128.%20Longest%20Consecutive%20Sequence/#union-find","text":"The ask is to have O(n) run time so this is going to be parsing through the array The number in the consecutive sequence can be in any order. So to answer if adding number nums[i] would increase any previos sequence or not we need to store pretty much all the sequence so far. The previous sequence could be as short as 1 so using DP to save something like 'max so far' would not work here The problem her is like a grouping. See < seq 1> <--- seq 2 ---> ... <--- seq n ---> Adding X, would X 1) Join any existing sequence? 1.1) If so, does X join 2 sequences to be 1 single sequence? 2) Or, X can't join any sequence and create a new one? - Naively we could save 'ranges' of the sequences so far and check if X can join any of them or not - A better way is to use 'Union Find' to join them together - The algorithm is following - Create a Map<Integer, Integer> that maps num to parent - For nums[i] , create a new entry and make the number as its own parent - If there is nums[i] - 1 or nums[i]+1 in the map, update their parent to be nums[i] - This will join the 'tree' of consecutive number together using the latest number as new root","title":"Union Find"},{"location":"Coding%20Interview/Problems/LeetCode/0128.%20Longest%20Consecutive%20Sequence/#counting","text":"The previous approach is generic in the sense that it can be used to group any thing Since this problem can be grouped by consecutive number, we can just rely on math to find/connect groups We can have a Map<Integer, Boolean> to track what number we seen has been already count For nums[i] , we count forward and backward. We flip the flag when counting so we don't count them again. Note that I thought of using Set instead but removing element from a Set while iterating can cause an exception","title":"Counting"},{"location":"Coding%20Interview/Problems/LeetCode/0128.%20Longest%20Consecutive%20Sequence/#solution","text":"// Basic Union Find class Solution { public int longestConsecutive ( int [] nums ) { Map < Integer , Integer > map = new HashMap <> (); for ( int n : nums ) { map . put ( n , n ); if ( map . containsKey ( n - 1 )) { int root = findRoot ( n - 1 , map ); map . put ( root , n ); } if ( map . containsKey ( n + 1 )) { int root = findRoot ( n - 1 , map ); map . put ( root , n ); } } Map < Integer , Integer > count = new HashMap <> (); int result = Integer . MIN_VALUE ; for ( int n : map . keySet ()) { int root = findRoot ( n , map ); int countSoFar = count . getOrDefault ( root , 0 ) + 1 ; count . put ( root , countSoFar ); result = Math . max ( result , countSoFar ); } return result ; } public int findRoot ( int n , Map < Integer , Integer > map ) { int root = map . get ( n ); while ( root != n ) { root = map . get ( n ); } return root ; } } // Counting class Solution { public int longestConsecutive ( int [] nums ) { if ( nums . length < 2 ) return nums . length ; Map < Integer , Boolean > map = new HashMap <> (); for ( int n : nums ) { if ( map . containsKey ( n )) continue ; map . put ( n , false ); } int max = Integer . MIN_VALUE ; for ( int n : nums ) { if ( map . get ( n )) continue ; map . put ( n , true ); int count = 1 ; int i = n - 1 ; while ( map . containsKey ( i )) { map . put ( i , true ); i -- ; count ++ ; } i = n + 1 ; while ( map . containsKey ( i )) { map . put ( i , true ); i ++ ; count ++ ; } max = Math . max ( max , count ); } return max ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0217.%20Contains%20Duplicate/","text":"Problem Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false Example 3: Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints: 1 <= nums.length <= 105 -109 <= nums[i] <= 109 Approaches We need a 'tally marks' that keep tracks of appearance Since the requirement is just 'at least twice', we don't need to actually count. We could just do 'seen' and 'unseen' - 2 states. Using Set<Integer> would be enough And the requirement is to return boolean, no need to collect all the 'non-distinct' values, we can short cut returning true once we run into an already 'seen' one We can go through the list If seen, return true If not seen, add the number into the Set One trick for Set in java is add() method return true if this set did not already contain the specified element. So we can shorten the code a little bit. Solution class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet < Integer > (); for ( int num : nums ) { if ( ! seen . add ( num )) return true ; } return false ; } }","title":"0217. Contains Duplicate"},{"location":"Coding%20Interview/Problems/LeetCode/0217.%20Contains%20Duplicate/#problem","text":"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false Example 3: Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints: 1 <= nums.length <= 105 -109 <= nums[i] <= 109","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0217.%20Contains%20Duplicate/#approaches","text":"We need a 'tally marks' that keep tracks of appearance Since the requirement is just 'at least twice', we don't need to actually count. We could just do 'seen' and 'unseen' - 2 states. Using Set<Integer> would be enough And the requirement is to return boolean, no need to collect all the 'non-distinct' values, we can short cut returning true once we run into an already 'seen' one We can go through the list If seen, return true If not seen, add the number into the Set One trick for Set in java is add() method return true if this set did not already contain the specified element. So we can shorten the code a little bit.","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0217.%20Contains%20Duplicate/#solution","text":"class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet < Integer > (); for ( int num : nums ) { if ( ! seen . add ( num )) return true ; } return false ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0238.%20Product%20of%20Array%20Except%20Self/","text":"Problem Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 <= nums.length <= 10^5 -30 <= nums[i] <= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) Approaches The brute force approach would be for each nums[i] calculating the product by going through the nums again. This approach is O(n^2) What we can better is to save the product value to be reused Consider, the answer[i] is the product of nums[0] - nums[i-1] x the product of nums[i+1] - nums[n-1] <- product before -> i <- product after -> Looping forward, we can get the product til i so we can get the 'product before' part Looping backward then would give us the 'product after' We can combine the two to get the answer For example nums [ 1, 2, 3, 4] Forward [ *, 1, 2, 6] Backward [24,12, 4, *] Answer = Forward x Backward = [24,12, 8, 6] Need to init * as 1 so we can multiple them all The approach uses 3 arrays so space is O(3n) To reduce this we can do in place calculation in the answer array itself For the forward loop, we can still do the same nums [ 1, 2, 3, 4] Answer [ *, 1, 2, 6] For the backward loop, we need to keep track of the total product so far because we don't have extra array to save Let's have right var to keep track of the total product backward. Then we can update the answer array by multiply answer[i] with right nums [ 1, 2, 3, 4] Answer [ *, 1, 2, 6] right 24,12, 4, * Answer [24,12, 8, 6] Solution // O(n) space solution class Solution { public int [] productExceptSelf ( int [] nums ) { int [] forward = new int [ nums . length ] ; int [] backward = new int [ nums . length ] ; int [] answer = new int [ nums . length ] ; forward [ 0 ] = backward [ nums . length - 1 ] = 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { forward [ i ] = forward [ i - 1 ] * nums [ i - 1 ] ; } for ( int i = nums . length - 2 ; i >= 0 ; i -- ) { backward [ i ] = backward [ i + 1 ] * nums [ i + 1 ] ; } for ( int i = 0 ; i < nums . length ; i ++ ) { answer [ i ] = forward [ i ] * backward [ i ] ; } return answer ; } } // O(1) space solution class Solution { public int [] productExceptSelf ( int [] nums ) { int [] answer = new int [ nums . length ] ; answer [ 0 ] = 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { answer [ i ] = answer [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = nums . length - 2 ; i >= 0 ; i -- ) { right *= nums [ i + 1 ] ; answer [ i ] *= right ; } return answer ; } }","title":"0238. Product of Array Except Self"},{"location":"Coding%20Interview/Problems/LeetCode/0238.%20Product%20of%20Array%20Except%20Self/#problem","text":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 <= nums.length <= 10^5 -30 <= nums[i] <= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0238.%20Product%20of%20Array%20Except%20Self/#approaches","text":"The brute force approach would be for each nums[i] calculating the product by going through the nums again. This approach is O(n^2) What we can better is to save the product value to be reused Consider, the answer[i] is the product of nums[0] - nums[i-1] x the product of nums[i+1] - nums[n-1] <- product before -> i <- product after -> Looping forward, we can get the product til i so we can get the 'product before' part Looping backward then would give us the 'product after' We can combine the two to get the answer For example nums [ 1, 2, 3, 4] Forward [ *, 1, 2, 6] Backward [24,12, 4, *] Answer = Forward x Backward = [24,12, 8, 6] Need to init * as 1 so we can multiple them all The approach uses 3 arrays so space is O(3n) To reduce this we can do in place calculation in the answer array itself For the forward loop, we can still do the same nums [ 1, 2, 3, 4] Answer [ *, 1, 2, 6] For the backward loop, we need to keep track of the total product so far because we don't have extra array to save Let's have right var to keep track of the total product backward. Then we can update the answer array by multiply answer[i] with right nums [ 1, 2, 3, 4] Answer [ *, 1, 2, 6] right 24,12, 4, * Answer [24,12, 8, 6]","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0238.%20Product%20of%20Array%20Except%20Self/#solution","text":"// O(n) space solution class Solution { public int [] productExceptSelf ( int [] nums ) { int [] forward = new int [ nums . length ] ; int [] backward = new int [ nums . length ] ; int [] answer = new int [ nums . length ] ; forward [ 0 ] = backward [ nums . length - 1 ] = 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { forward [ i ] = forward [ i - 1 ] * nums [ i - 1 ] ; } for ( int i = nums . length - 2 ; i >= 0 ; i -- ) { backward [ i ] = backward [ i + 1 ] * nums [ i + 1 ] ; } for ( int i = 0 ; i < nums . length ; i ++ ) { answer [ i ] = forward [ i ] * backward [ i ] ; } return answer ; } } // O(1) space solution class Solution { public int [] productExceptSelf ( int [] nums ) { int [] answer = new int [ nums . length ] ; answer [ 0 ] = 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { answer [ i ] = answer [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = nums . length - 2 ; i >= 0 ; i -- ) { right *= nums [ i + 1 ] ; answer [ i ] *= right ; } return answer ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0242.%20Valid%20Anagram/","text":"Problem Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \"anagram\", t = \"nagaram\" Output: true Example 2: Input: s = \"rat\", t = \"car\" Output: false Constraints: 1 <= s.length, t.length <= 5 * 104 s and t consist of lowercase English letters. Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case? Approaches s is an anagram of t if s has same frequency/count of character exactly same as that of t We can do 'tally marks' of s in a Map<Character, Integer> Next, we go through each character in t and 'unmark' If there is a char in t that missing in the 'tally marks' OR there is any character left in the 'tally marks' then s is not an anagram of t Using Map<Character, Integer> should be able to handle unicode. Otherwise, an array of int[] covering all know char i.e. size = 26 to cover all lower case here should be enough Solution class Solution { public boolean isAnagram ( String s , String t ) { Map < Character , Integer > count = new HashMap <> (); for ( char c : s . toCharArray ()) { count . put ( c , count . getOrDefault ( c , 0 ) + 1 ); } for ( char c : t . toCharArray ()) { if ( ! count . containsKey ( c )) { return false ; } int freq = count . get ( c ) - 1 ; if ( freq == 0 ) { count . remove ( c ); } else { count . put ( c , freq ); } } return count . size () == 0 ; } }","title":"0242. Valid Anagram"},{"location":"Coding%20Interview/Problems/LeetCode/0242.%20Valid%20Anagram/#problem","text":"Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \"anagram\", t = \"nagaram\" Output: true Example 2: Input: s = \"rat\", t = \"car\" Output: false Constraints: 1 <= s.length, t.length <= 5 * 104 s and t consist of lowercase English letters. Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0242.%20Valid%20Anagram/#approaches","text":"s is an anagram of t if s has same frequency/count of character exactly same as that of t We can do 'tally marks' of s in a Map<Character, Integer> Next, we go through each character in t and 'unmark' If there is a char in t that missing in the 'tally marks' OR there is any character left in the 'tally marks' then s is not an anagram of t Using Map<Character, Integer> should be able to handle unicode. Otherwise, an array of int[] covering all know char i.e. size = 26 to cover all lower case here should be enough","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0242.%20Valid%20Anagram/#solution","text":"class Solution { public boolean isAnagram ( String s , String t ) { Map < Character , Integer > count = new HashMap <> (); for ( char c : s . toCharArray ()) { count . put ( c , count . getOrDefault ( c , 0 ) + 1 ); } for ( char c : t . toCharArray ()) { if ( ! count . containsKey ( c )) { return false ; } int freq = count . get ( c ) - 1 ; if ( freq == 0 ) { count . remove ( c ); } else { count . put ( c , freq ); } } return count . size () == 0 ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0347.%20Top%20K%20Frequent%20Elements/","text":"Problem Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 10^5 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size. Approaches We need to know the frequency so first loop would be counting Intuitively, we can just sort the frequency from max -> min and get the top k for the answer This approach would be O(n) for collecting frequency + O(n log n) for sorting the frequency However, the question states explicitly that the solution should be faster than O(n log n) so we need a better solution Note that we don't need to sort them all. We want 'max' values for k times This fits perfectly with Heap. Another approach is to do one-sided quick sort We can throw frequency data in to a max heap and pull the max value k time Run time complexity Building heap is O(n) NOT O(n log n) as it may seems. READ MORE ABOUT HEAPIFY! The main reason is that we need to do heapify only the first half only as the bottom half are leaves For the first half that we need to do comparison, it's based on the height of the element. The higher the height the lower the number of element The total no. of comparison is still less than n Pulling max value is O(log n) as we siftDown . We do this k times so it's O(k log n) Total is O(n) + O(k log n) NeedCode has example of using minHeap and keep pruning the min value if the heap has element > k We can also try to build heap ourselves if we want Solution class Solution { public int [] topKFrequent ( int [] nums , int k ) { PriorityQueue < Map . Entry < Integer , Integer >> heap = new PriorityQueue <> (( a , b ) -> b . getValue () - a . getValue ()); Map < Integer , Integer > freqs = new HashMap <> (); for ( int n : nums ) { freqs . put ( n , freqs . getOrDefault ( n , 0 ) + 1 ); } heap . addAll ( freqs . entrySet ()); int [] result = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { result [ i ] = heap . poll (). getKey (); } return result ; } }","title":"0347. Top K Frequent Elements"},{"location":"Coding%20Interview/Problems/LeetCode/0347.%20Top%20K%20Frequent%20Elements/#problem","text":"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 10^5 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/0347.%20Top%20K%20Frequent%20Elements/#approaches","text":"We need to know the frequency so first loop would be counting Intuitively, we can just sort the frequency from max -> min and get the top k for the answer This approach would be O(n) for collecting frequency + O(n log n) for sorting the frequency However, the question states explicitly that the solution should be faster than O(n log n) so we need a better solution Note that we don't need to sort them all. We want 'max' values for k times This fits perfectly with Heap. Another approach is to do one-sided quick sort We can throw frequency data in to a max heap and pull the max value k time Run time complexity Building heap is O(n) NOT O(n log n) as it may seems. READ MORE ABOUT HEAPIFY! The main reason is that we need to do heapify only the first half only as the bottom half are leaves For the first half that we need to do comparison, it's based on the height of the element. The higher the height the lower the number of element The total no. of comparison is still less than n Pulling max value is O(log n) as we siftDown . We do this k times so it's O(k log n) Total is O(n) + O(k log n) NeedCode has example of using minHeap and keep pruning the min value if the heap has element > k We can also try to build heap ourselves if we want","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/0347.%20Top%20K%20Frequent%20Elements/#solution","text":"class Solution { public int [] topKFrequent ( int [] nums , int k ) { PriorityQueue < Map . Entry < Integer , Integer >> heap = new PriorityQueue <> (( a , b ) -> b . getValue () - a . getValue ()); Map < Integer , Integer > freqs = new HashMap <> (); for ( int n : nums ) { freqs . put ( n , freqs . getOrDefault ( n , 0 ) + 1 ); } heap . addAll ( freqs . entrySet ()); int [] result = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { result [ i ] = heap . poll (). getKey (); } return result ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/0950.%20Reveal%20Cards%20In%20Increasing%20Order/","text":"Problem You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i]. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. You will do the following steps repeatedly until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. Note that the first entry in the answer is considered to be the top of the deck. Example 1: Input: deck = [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. Example 2: Input: deck = [1,1000] Output: [1,1000] Constraints: 1 <= deck.length <= 1000 1 <= deck[i] <= 106 All the values of deck are unique.","title":"0950. Reveal Cards In Increasing Order"},{"location":"Coding%20Interview/Problems/LeetCode/0950.%20Reveal%20Cards%20In%20Increasing%20Order/#problem","text":"You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i]. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. You will do the following steps repeatedly until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. Note that the first entry in the answer is considered to be the top of the deck. Example 1: Input: deck = [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. Example 2: Input: deck = [1,1000] Output: [1,1000] Constraints: 1 <= deck.length <= 1000 1 <= deck[i] <= 106 All the values of deck are unique.","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/1143.%20Longest%20Common%20Subsequence/","text":"Problem Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\". A common subsequence of two strings is a subsequence that is common to both strings. Example 1: Input: text1 = \"abcde\", text2 = \"ace\" Output: 3 Explanation: The longest common subsequence is \"ace\" and its length is 3. Example 2: Input: text1 = \"abc\", text2 = \"abc\" Output: 3 Explanation: The longest common subsequence is \"abc\" and its length is 3. Example 3: Input: text1 = \"abc\", text2 = \"def\" Output: 0 Explanation: There is no such common subsequence, so the result is 0. Constraints: 1 <= text1.length, text2.length <= 1000 text1 and text2 consist of only lowercase English characters. Approaches Intuitively, we can have 2 pointers - i for text1 and j for text2 - that we can go through each char of both text For each i and j , if text1[i] == text2[j] then the sequence increase by 1 i.e. dp[i][j] = dp[i-1][j-1] + 1 they are not equal then the max sequence at i and j is max of dp[i-1][j] + dp[][j-1] From the equation above, dp[i][j] requires previous 3 - UP, LEFT, and UP-LEFT dp array j 0 1 2 3 4 ... i 0 A B ... 1 C X 2 3 4 ... From example above, X is calculated from A , B , and C If we start from dp[0][0] for the first char of both texts, we will need special check when it hit boundary We could add additional row/col and start first char of both texts at dp[1][1] instead to avoid special case like this dp array j 0 1 2 3 4 ... text2.length() 0 0 0 0 0 0 ... . 1 0 . . . . . 2 0 . . . . . i 3 0 . . . . . 4 0 . . . . . ... text1.length() X X, which is the answer, is at dp[text1.length()][text2.length()] Solution class Solution { public int longestCommonSubsequence ( String text1 , String text2 ) { int dp [][] = new int [ text1 . length () + 1 ][ text2 . length () + 1 ] ; for ( int i = 0 ; i < text1 . length (); i ++ ) { for ( int j = 0 ; j < text2 . length (); j ++ ) { if ( text1 . charAt ( i ) == text2 . charAt ( j )) { dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] + 1 ; } else { dp [ i + 1 ][ j + 1 ] = Math . max ( dp [ i ][ j + 1 ] , dp [ i + 1 ][ j ] ); } } } return dp [ text1 . length () ][ text2 . length () ] ; } }","title":"1143. Longest Common Subsequence"},{"location":"Coding%20Interview/Problems/LeetCode/1143.%20Longest%20Common%20Subsequence/#problem","text":"Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\". A common subsequence of two strings is a subsequence that is common to both strings. Example 1: Input: text1 = \"abcde\", text2 = \"ace\" Output: 3 Explanation: The longest common subsequence is \"ace\" and its length is 3. Example 2: Input: text1 = \"abc\", text2 = \"abc\" Output: 3 Explanation: The longest common subsequence is \"abc\" and its length is 3. Example 3: Input: text1 = \"abc\", text2 = \"def\" Output: 0 Explanation: There is no such common subsequence, so the result is 0. Constraints: 1 <= text1.length, text2.length <= 1000 text1 and text2 consist of only lowercase English characters.","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/1143.%20Longest%20Common%20Subsequence/#approaches","text":"Intuitively, we can have 2 pointers - i for text1 and j for text2 - that we can go through each char of both text For each i and j , if text1[i] == text2[j] then the sequence increase by 1 i.e. dp[i][j] = dp[i-1][j-1] + 1 they are not equal then the max sequence at i and j is max of dp[i-1][j] + dp[][j-1] From the equation above, dp[i][j] requires previous 3 - UP, LEFT, and UP-LEFT dp array j 0 1 2 3 4 ... i 0 A B ... 1 C X 2 3 4 ... From example above, X is calculated from A , B , and C If we start from dp[0][0] for the first char of both texts, we will need special check when it hit boundary We could add additional row/col and start first char of both texts at dp[1][1] instead to avoid special case like this dp array j 0 1 2 3 4 ... text2.length() 0 0 0 0 0 0 ... . 1 0 . . . . . 2 0 . . . . . i 3 0 . . . . . 4 0 . . . . . ... text1.length() X X, which is the answer, is at dp[text1.length()][text2.length()]","title":"Approaches"},{"location":"Coding%20Interview/Problems/LeetCode/1143.%20Longest%20Common%20Subsequence/#solution","text":"class Solution { public int longestCommonSubsequence ( String text1 , String text2 ) { int dp [][] = new int [ text1 . length () + 1 ][ text2 . length () + 1 ] ; for ( int i = 0 ; i < text1 . length (); i ++ ) { for ( int j = 0 ; j < text2 . length (); j ++ ) { if ( text1 . charAt ( i ) == text2 . charAt ( j )) { dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] + 1 ; } else { dp [ i + 1 ][ j + 1 ] = Math . max ( dp [ i ][ j + 1 ] , dp [ i + 1 ][ j ] ); } } } return dp [ text1 . length () ][ text2 . length () ] ; } }","title":"Solution"},{"location":"Coding%20Interview/Problems/LeetCode/1713.%20Minimum%20Operations%20to%20Make%20a%20Subsequence/","text":"Problem You are given an array target that consists of distinct integers and another integer array arr that can have duplicates. In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array. Return the minimum number of operations needed to make target a subsequence of arr. A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not. Example 1: Input: target = [5,1,3], arr = [9,4,2,3,4] Output: 2 Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr. Example 2: Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1] Output: 3 Constraints: 1 <= target.length, arr.length <= 10^5 1 <= target[i], arr[i] <= 10^9 target contains no duplicates.","title":"1713. Minimum Operations to Make a Subsequence"},{"location":"Coding%20Interview/Problems/LeetCode/1713.%20Minimum%20Operations%20to%20Make%20a%20Subsequence/#problem","text":"You are given an array target that consists of distinct integers and another integer array arr that can have duplicates. In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array. Return the minimum number of operations needed to make target a subsequence of arr. A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not. Example 1: Input: target = [5,1,3], arr = [9,4,2,3,4] Output: 2 Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr. Example 2: Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1] Output: 3 Constraints: 1 <= target.length, arr.length <= 10^5 1 <= target[i], arr[i] <= 10^9 target contains no duplicates.","title":"Problem"},{"location":"Coding%20Interview/Problems/LeetCode/2191.%20Sort%20the%20Jumbled%20Numbers/","text":"Problem You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system. The mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9. You are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements. Notes: - Elements with the same mapped values should appear in the same relative order as in the input. - The elements of nums should only be sorted based on their mapped values and not be replaced by them. Example 1: Input: mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38] Output: [338,38,991] Explanation: Map the number 991 as follows: 1. mapping[9] = 6, so all occurrences of the digit 9 will become 6. 2. mapping[1] = 9, so all occurrences of the digit 1 will become 9. Therefore, the mapped value of 991 is 669. 338 maps to 007, or 7 after removing the leading zeros. 38 maps to 07, which is also 7 after removing leading zeros. Since 338 and 38 share the same mapped value, they should remain in the same relative order, so 338 comes before 38. Thus, the sorted array is [338,38,991]. Example 2: Input: mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123] Output: [123,456,789] Explanation: 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus, the sorted array is [123,456,789]. Constraints: mapping.length == 10 0 <= mapping[i] <= 9 All the values of mapping[i] are unique. 1 <= nums.length <= 3 * 104 0 <= nums[i] < 10^9","title":"2191. Sort the Jumbled Numbers"},{"location":"Coding%20Interview/Problems/LeetCode/2191.%20Sort%20the%20Jumbled%20Numbers/#problem","text":"You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system. The mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9. You are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements. Notes: - Elements with the same mapped values should appear in the same relative order as in the input. - The elements of nums should only be sorted based on their mapped values and not be replaced by them. Example 1: Input: mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38] Output: [338,38,991] Explanation: Map the number 991 as follows: 1. mapping[9] = 6, so all occurrences of the digit 9 will become 6. 2. mapping[1] = 9, so all occurrences of the digit 1 will become 9. Therefore, the mapped value of 991 is 669. 338 maps to 007, or 7 after removing the leading zeros. 38 maps to 07, which is also 7 after removing leading zeros. Since 338 and 38 share the same mapped value, they should remain in the same relative order, so 338 comes before 38. Thus, the sorted array is [338,38,991]. Example 2: Input: mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123] Output: [123,456,789] Explanation: 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus, the sorted array is [123,456,789]. Constraints: mapping.length == 10 0 <= mapping[i] <= 9 All the values of mapping[i] are unique. 1 <= nums.length <= 3 * 104 0 <= nums[i] < 10^9","title":"Problem"},{"location":"Coding%20Interview/System%20Design/Cheat%20Sheet/","text":"Requirements and Scope (3-10 minutes) Functional Requirements Data: CRUD + Search User: Sign Up/In Notification Metrics/Analytics - Business value metrics Localization: Language, Location, Different kind of content Personalization: Usage history, Friends/Follower Non-functional Requirements Availability/Latency/Consistency Different functions/users need differently Find key requirements and draw scope line Capacity Estimation (3-5 minutes) TPS Ask/Assume a number: active users, interaction per day, etc Calculate to TPS: day / 24 / 3600 = second or / 100k round up Storage Assume size of the data: record breakdown How long we need to keep the data? Peak = Estimate x 2 Downtime 99.9% = 1.44 minutes/day = 8.77 hours/year 1 Billion = 1 GB, 1 Trillion = 1 TB, 1 Quadrillion = 1 PB High Level Design (5-10 minutes) Draw Components: clients, service, database, cache, CDN, message queue Database Types: SQL/NoSQL/Graph/Mix Offer Alternatives Design Deep Dive (10-25 minutes) Ask/Assume priority Bottle necks and scaling Algorithm/API Data Flow Connection Wrap Up (3-5 minutes) Review the key design decisions and how they address the problem Components/Use cases worth exploring but didn't have time","title":"Cheat Sheet"},{"location":"Coding%20Interview/System%20Design/Patterns/01.%20Unique%20ID%20Generator/","text":"Problem The system needs a globally unique ID Solution Database's auto increment Pros: Easy to implement for a single server Cons: Hard to scale with multiple DB servers. May be able to do odd/even but doesn't scale well UUID Pros: Easy to implement; Hard to have collision Cons: Can't use ID to sort; UUID is long (16 chars - 128 bits) Ticket Server Pros: Easy to implement; Numeric/Sortable Cons: Single point of failure; Hard to scale Twitter snowflake The trick is to break 64 bits into sections - timestamp|data center ID|server ID|sequence number - Sign bit (1 bit) - Always 0. Reserved for signed/unsigned cases in the future - Timestamp (41 bits) - Covers around 70 years. Use custom epoch - Data center ID (5 bits) - Covers 32 data centers - Machine ID (5 bits) - Covers 32 servers / data centers - Sequence Number (12 bits) - Covers 4k / second - Pros: Numeric/Sortable; Scalable as we can have multiple ID generating servers - Cons: Hard to implement; Clock synchronization Key Generator Server The trick is to pre-generate unique keys and save them in the database to make sure to key reuse. The key can be numbers or unique string. - Pros: Can cache/preload into the server with specific range that needs the key; The key can be 'returned/recycled' - Cons: Single point of failure; Need a replica; Needs a lot of space to store all possible keys ## Usage - Tiny URL - Convert ID to String using base 62 (0-9, a-b, A-Z)","title":"01. Unique ID Generator"},{"location":"Coding%20Interview/System%20Design/Patterns/01.%20Unique%20ID%20Generator/#problem","text":"The system needs a globally unique ID","title":"Problem"},{"location":"Coding%20Interview/System%20Design/Patterns/01.%20Unique%20ID%20Generator/#solution","text":"Database's auto increment Pros: Easy to implement for a single server Cons: Hard to scale with multiple DB servers. May be able to do odd/even but doesn't scale well UUID Pros: Easy to implement; Hard to have collision Cons: Can't use ID to sort; UUID is long (16 chars - 128 bits) Ticket Server Pros: Easy to implement; Numeric/Sortable Cons: Single point of failure; Hard to scale Twitter snowflake The trick is to break 64 bits into sections - timestamp|data center ID|server ID|sequence number - Sign bit (1 bit) - Always 0. Reserved for signed/unsigned cases in the future - Timestamp (41 bits) - Covers around 70 years. Use custom epoch - Data center ID (5 bits) - Covers 32 data centers - Machine ID (5 bits) - Covers 32 servers / data centers - Sequence Number (12 bits) - Covers 4k / second - Pros: Numeric/Sortable; Scalable as we can have multiple ID generating servers - Cons: Hard to implement; Clock synchronization Key Generator Server The trick is to pre-generate unique keys and save them in the database to make sure to key reuse. The key can be numbers or unique string. - Pros: Can cache/preload into the server with specific range that needs the key; The key can be 'returned/recycled' - Cons: Single point of failure; Need a replica; Needs a lot of space to store all possible keys ## Usage - Tiny URL - Convert ID to String using base 62 (0-9, a-b, A-Z)","title":"Solution"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/","text":"Championship Manager 01/02 Installation Download ISO and DB patch (v.3.9.68) from https://www.myabandonware.com/game/championship-manager-season-01-02-a2h Download Nick's patch from github https://github.com/nckstwrt/CM0102Patcher . Recommended pathes are Enable coloured attributes - Higher attributes will be using different color Enable idle sensititvity - Game will use less CPU. This is really useful when running on wine. Enable 7 substitues Show star players - You want to know who is the best right? Show hidden attributes - This is useful tos injury prone, consistency, big match, and 1:1 for GK Disable unprotected contract - I hate losing players coz the unprotected contract rules Remove UK 3 foreign player limit EEC Patch (Under 'Tools') - Make all nations in EU Mics Patches/Uncap20s.patch (Under 'Misc Pathes') - Some players have higher value than 20. This patch will allow us to see that. Mics Patches/SeeAnytTeamsFinancesV2.patch (Under 'Mics Pathes') - See how rich other clubs are so we can get as much money as possible from them. Misc Pathces/GiveMoreOptionsInOfferDropDownV2.pathc - More options in the dropdown when offering to buy a player Tips/Tricks Selling player To sell players for higher transfer fee, When a club made an offer, negotiate by exchanging a player. They will come back with a better deal For players who are in national team already (i.e. the player will for sure play in the national team soon and somewhat famous) Set the player's value low (like 1m) and put the player in transfer list. Many clubs will be interested in the player due to the lower fee. When a club made an offer, keep the transfer fee low but negotiate with a lot of fee for 'Fee after 1 Internal Apps'. We will get money just when the player plays in national team, which is typically a few months away The club will agree to the negotiation based on pretty much the money they have available, not the player's real value I used this trick to sell Biscan and Babbel for 1m+95m each from Barcelona. This can be an exceptional case though as most clubs could effort only about ~20m to 40m max. Buying player In case your club is not famous, players may not even want to talk to the club. In such case, we can't do anything. But, if we can still make an offer, but the player states that he is not interested to join your club. You can do the following Set 'Weekly Wage' a bit lower than your target (but not too low that the player would reject) Increase 'Signing on Fee'. Double the default value Reduce the 'Contract Expires' to 'Month-to-Month'. This short period will make the player interested in Once the transfer is done, the player will be under 'rolling contract' state so you will need to offer a long term contract. This is when you should bump up the 'Weekly Wage' a bit more to match the player's request. This is the reason to push the wage of the first contract lower so you have room to increase here. (Unless you are willing to pay the player a lot and no need to control your budget) This trick requires paying multiple sign on fee so you should do this with a key player when you have enough money. My starting save This is my note on my save playing Liverpool at the start of the season. This save has shortlisted, bidded, and put some players on transfer list. I am selling Babbel, Biscan, and Hamann. They can make a lot of money and I plan to buy some players to replace them The following are teams that making offer and the max fee they would accept Barcelona - 1+95m Real Madred - 1+85m Valencia - 1+40m Dortmund - 1+20m Bayern - 1+20m Porto - 1+6m (Xavier) Racing - 1+6m (Xavier) Lille - 1+6m (Xavier) For this save, I would aim to get 1+95m for Babble from Barcelona 1+85m for Biscan from Real Madrid (or actually I got 1+95m from Barcelona) 1+40m for Hamann from Valencia ~1+5m for Xavier I could drain a lot of money from Barcelona they will have financial crisis later. This allowed me to buy their player for cheap like Saviola and Riquelme My favorite players The following players that I like to buy. Note that not including the famous ones though Anastasios Skalidis (19) - Super Greek striker. He doesn't want to join Liverpool in the first season. Try to buy him in 2nd season for cheap Alexandros Papdopoulos (16) - Another super Greek striker. He doesn't want to join in the first season either. Buy him later and wait for a year or so. He will be great along with Skalidis Mike Duff (23) - Cheap and reliable right back (that's why I sell Babbel). You will not need any right back any more. Ibrahim Said (21) - He can play both CB and DMC really well. That's why I sell Hamann. He is non-EU though so without patch you need to be careful Mark Kerr (19) - Young reliable MC. Not super flashy but get the job done. Isaac Okoronkwo (23) - CB and right back. Cheap and reliable. Non-EU player though'; Taribo Wast (27) - CB and left back. Free transfer. Players to watch Cherno Samba (15) - The famous striker. I don't play long enough to see him thrive in my saves though Stephen McPhee (20) - He could turn into a great player. He wasn't great in one of my save though so you better watch how he progresses Fernando Cavenaghi (17) - I wanted to sign him but never. I assume that he is great.","title":"Championship Manager 01/02"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/#championship-manager-0102","text":"","title":"Championship Manager 01/02"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/#installation","text":"Download ISO and DB patch (v.3.9.68) from https://www.myabandonware.com/game/championship-manager-season-01-02-a2h Download Nick's patch from github https://github.com/nckstwrt/CM0102Patcher . Recommended pathes are Enable coloured attributes - Higher attributes will be using different color Enable idle sensititvity - Game will use less CPU. This is really useful when running on wine. Enable 7 substitues Show star players - You want to know who is the best right? Show hidden attributes - This is useful tos injury prone, consistency, big match, and 1:1 for GK Disable unprotected contract - I hate losing players coz the unprotected contract rules Remove UK 3 foreign player limit EEC Patch (Under 'Tools') - Make all nations in EU Mics Patches/Uncap20s.patch (Under 'Misc Pathes') - Some players have higher value than 20. This patch will allow us to see that. Mics Patches/SeeAnytTeamsFinancesV2.patch (Under 'Mics Pathes') - See how rich other clubs are so we can get as much money as possible from them. Misc Pathces/GiveMoreOptionsInOfferDropDownV2.pathc - More options in the dropdown when offering to buy a player","title":"Installation"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/#tipstricks","text":"","title":"Tips/Tricks"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/#selling-player","text":"To sell players for higher transfer fee, When a club made an offer, negotiate by exchanging a player. They will come back with a better deal For players who are in national team already (i.e. the player will for sure play in the national team soon and somewhat famous) Set the player's value low (like 1m) and put the player in transfer list. Many clubs will be interested in the player due to the lower fee. When a club made an offer, keep the transfer fee low but negotiate with a lot of fee for 'Fee after 1 Internal Apps'. We will get money just when the player plays in national team, which is typically a few months away The club will agree to the negotiation based on pretty much the money they have available, not the player's real value I used this trick to sell Biscan and Babbel for 1m+95m each from Barcelona. This can be an exceptional case though as most clubs could effort only about ~20m to 40m max.","title":"Selling player"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/#buying-player","text":"In case your club is not famous, players may not even want to talk to the club. In such case, we can't do anything. But, if we can still make an offer, but the player states that he is not interested to join your club. You can do the following Set 'Weekly Wage' a bit lower than your target (but not too low that the player would reject) Increase 'Signing on Fee'. Double the default value Reduce the 'Contract Expires' to 'Month-to-Month'. This short period will make the player interested in Once the transfer is done, the player will be under 'rolling contract' state so you will need to offer a long term contract. This is when you should bump up the 'Weekly Wage' a bit more to match the player's request. This is the reason to push the wage of the first contract lower so you have room to increase here. (Unless you are willing to pay the player a lot and no need to control your budget) This trick requires paying multiple sign on fee so you should do this with a key player when you have enough money.","title":"Buying player"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/#my-starting-save","text":"This is my note on my save playing Liverpool at the start of the season. This save has shortlisted, bidded, and put some players on transfer list. I am selling Babbel, Biscan, and Hamann. They can make a lot of money and I plan to buy some players to replace them The following are teams that making offer and the max fee they would accept Barcelona - 1+95m Real Madred - 1+85m Valencia - 1+40m Dortmund - 1+20m Bayern - 1+20m Porto - 1+6m (Xavier) Racing - 1+6m (Xavier) Lille - 1+6m (Xavier) For this save, I would aim to get 1+95m for Babble from Barcelona 1+85m for Biscan from Real Madrid (or actually I got 1+95m from Barcelona) 1+40m for Hamann from Valencia ~1+5m for Xavier I could drain a lot of money from Barcelona they will have financial crisis later. This allowed me to buy their player for cheap like Saviola and Riquelme","title":"My starting save"},{"location":"Entertainment/Games/Championship%20Manager/cm0102/#my-favorite-players","text":"The following players that I like to buy. Note that not including the famous ones though Anastasios Skalidis (19) - Super Greek striker. He doesn't want to join Liverpool in the first season. Try to buy him in 2nd season for cheap Alexandros Papdopoulos (16) - Another super Greek striker. He doesn't want to join in the first season either. Buy him later and wait for a year or so. He will be great along with Skalidis Mike Duff (23) - Cheap and reliable right back (that's why I sell Babbel). You will not need any right back any more. Ibrahim Said (21) - He can play both CB and DMC really well. That's why I sell Hamann. He is non-EU though so without patch you need to be careful Mark Kerr (19) - Young reliable MC. Not super flashy but get the job done. Isaac Okoronkwo (23) - CB and right back. Cheap and reliable. Non-EU player though'; Taribo Wast (27) - CB and left back. Free transfer. Players to watch Cherno Samba (15) - The famous striker. I don't play long enough to see him thrive in my saves though Stephen McPhee (20) - He could turn into a great player. He wasn't great in one of my save though so you better watch how he progresses Fernando Cavenaghi (17) - I wanted to sign him but never. I assume that he is great.","title":"My favorite players"},{"location":"Programming/Java/Stream/stream/","text":"Stream API boxed() Convert primitive array to List int [] input = new int [] { 1 , 2 , 3 , 4 }; List < Integer > output = Arrays . stream ( input ). boxed (). collect ( Collectors . toList ()); Reference - https://www.baeldung.com/java-primitive-array-to-list","title":"Stream API"},{"location":"Programming/Java/Stream/stream/#stream-api","text":"","title":"Stream API"},{"location":"Programming/Java/Stream/stream/#boxed","text":"Convert primitive array to List int [] input = new int [] { 1 , 2 , 3 , 4 }; List < Integer > output = Arrays . stream ( input ). boxed (). collect ( Collectors . toList ()); Reference - https://www.baeldung.com/java-primitive-array-to-list","title":"boxed()"},{"location":"System%20Admin/Disk/format/","text":"Formatting disk using CLI Context I have a new external harddrive that I want to use with my Ubuntu server. The server doesn't have GUI easily accessible so I want to format the drive via command line. Note that the command here is based on Ubuntu 20.04 that I have at the moment Instruction Checking partition First, we need to check the drive/partition that the server is referring to the newly installed disk lsblk or use -f option to also display the file system lsblk -f This will show something like this NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT loop0 7:0 0 42.2M 1 loop /snap/snapd/14066 loop1 7:1 0 61.9M 1 loop /snap/core20/1242 loop2 7:2 0 73M 1 loop /snap/lxd/22147 loop3 7:3 0 73.1M 1 loop /snap/lxd/22114 loop4 7:4 0 55.5M 1 loop /snap/core18/2246 loop6 7:6 0 43.3M 1 loop /snap/snapd/14295 loop7 7:7 0 55.5M 1 loop /snap/core18/2253 loop8 7:8 0 61.9M 1 loop /snap/core20/1270 sda 8:0 0 477G 0 disk \u251c\u2500sda1 8:1 0 512M 0 part /boot/efi \u2514\u2500sda2 8:2 0 476.4G 0 part / sdc 8:32 0 1.8T 0 disk \u251c\u2500sdc1 8:33 0 1.6T 0 part /mnt/ABC \u251c\u2500sdc2 8:34 0 1K 0 part \u251c\u2500sdc5 8:37 0 100G 0 part \u2502 \u2514\u2500veracrypt1 253:0 0 100G 0 dm /mnt/DEF \u2514\u2500sdc6 8:38 0 100G 0 part \u2514\u2500veracrypt2 253:1 0 100G 0 dm /mnt/GHI sdd 8:48 0 1.8T 0 disk \u251c\u2500sdd1 8:49 0 200M 0 part \u2514\u2500sdd2 8:50 0 1.8T 0 part \u2514\u2500veracrypt3 253:2 0 1.8T 0 dm /mnt/JKL sde 8:64 0 3.7T 0 disk \u251c\u2500sde1 8:65 0 128G 0 part /mnt/MNO \u2514\u2500sde2 8:66 0 3.5T 0 part \u2514\u2500veracrypt4 253:3 0 3.5T 0 dm /mnt/PQR sdf 8:80 0 10.9T 0 disk \u2514\u2500sdf1 8:81 0 10.9T 0 part /mnt/STU sr0 11:0 1 1024M 0 rom Run this before and after connecting the drive so you will know which one is the disk you added. Get the drive name i.e. sdb (typically if it's the second drive of the server) Formatting the disk My drive was preformatted with NTFS. Even though it works with Ubuntu, I want the drive to perform best in the environment and I don't plan to connect this drive to Windows machine. I plan to address compatibity by sharing this drive via Samba instead. In this case /dev/sdg1 is my partition To format to ext4 sudo mkfs -t ext4 /dev/sdg1 To format to fat32 sudo mkfs -t vfat /dev/sdg1 To format to fat32 sudo mkfs -t ntfs /dev/sdg1 It will take a while. After it's done, check the file system again with lsblk -f Make sure it shows the file system you just chose and get the UUID sdg \u2514\u2500sdg1 ext4 <uuid> Mount the disk Create mount point sudo mkdir -p <mountpoint> Update /etc/fstab to mount the disk automatically sudo vi /etc/fstab Add a row like this. The config I use is for ext4 file system. For mounting ntfs or others, refer to fstab UUID=<uuid> <mountpoint> ext4 defaults,noatime 0 0 Verify the mounting fstab will work after reboot so to mount the drive immediately after updating fstab run the following # to mount the specific mountpoint sudo mount <mountpoint> # or, to mount all the mountpoints defined in fstab sudo mount -a Reference https://phoenixnap.com/kb/linux-format-disk","title":"Formatting disk using CLI"},{"location":"System%20Admin/Disk/format/#formatting-disk-using-cli","text":"","title":"Formatting disk using CLI"},{"location":"System%20Admin/Disk/format/#context","text":"I have a new external harddrive that I want to use with my Ubuntu server. The server doesn't have GUI easily accessible so I want to format the drive via command line. Note that the command here is based on Ubuntu 20.04 that I have at the moment","title":"Context"},{"location":"System%20Admin/Disk/format/#instruction","text":"","title":"Instruction"},{"location":"System%20Admin/Disk/format/#checking-partition","text":"First, we need to check the drive/partition that the server is referring to the newly installed disk lsblk or use -f option to also display the file system lsblk -f This will show something like this NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT loop0 7:0 0 42.2M 1 loop /snap/snapd/14066 loop1 7:1 0 61.9M 1 loop /snap/core20/1242 loop2 7:2 0 73M 1 loop /snap/lxd/22147 loop3 7:3 0 73.1M 1 loop /snap/lxd/22114 loop4 7:4 0 55.5M 1 loop /snap/core18/2246 loop6 7:6 0 43.3M 1 loop /snap/snapd/14295 loop7 7:7 0 55.5M 1 loop /snap/core18/2253 loop8 7:8 0 61.9M 1 loop /snap/core20/1270 sda 8:0 0 477G 0 disk \u251c\u2500sda1 8:1 0 512M 0 part /boot/efi \u2514\u2500sda2 8:2 0 476.4G 0 part / sdc 8:32 0 1.8T 0 disk \u251c\u2500sdc1 8:33 0 1.6T 0 part /mnt/ABC \u251c\u2500sdc2 8:34 0 1K 0 part \u251c\u2500sdc5 8:37 0 100G 0 part \u2502 \u2514\u2500veracrypt1 253:0 0 100G 0 dm /mnt/DEF \u2514\u2500sdc6 8:38 0 100G 0 part \u2514\u2500veracrypt2 253:1 0 100G 0 dm /mnt/GHI sdd 8:48 0 1.8T 0 disk \u251c\u2500sdd1 8:49 0 200M 0 part \u2514\u2500sdd2 8:50 0 1.8T 0 part \u2514\u2500veracrypt3 253:2 0 1.8T 0 dm /mnt/JKL sde 8:64 0 3.7T 0 disk \u251c\u2500sde1 8:65 0 128G 0 part /mnt/MNO \u2514\u2500sde2 8:66 0 3.5T 0 part \u2514\u2500veracrypt4 253:3 0 3.5T 0 dm /mnt/PQR sdf 8:80 0 10.9T 0 disk \u2514\u2500sdf1 8:81 0 10.9T 0 part /mnt/STU sr0 11:0 1 1024M 0 rom Run this before and after connecting the drive so you will know which one is the disk you added. Get the drive name i.e. sdb (typically if it's the second drive of the server)","title":"Checking partition"},{"location":"System%20Admin/Disk/format/#formatting-the-disk","text":"My drive was preformatted with NTFS. Even though it works with Ubuntu, I want the drive to perform best in the environment and I don't plan to connect this drive to Windows machine. I plan to address compatibity by sharing this drive via Samba instead. In this case /dev/sdg1 is my partition To format to ext4 sudo mkfs -t ext4 /dev/sdg1 To format to fat32 sudo mkfs -t vfat /dev/sdg1 To format to fat32 sudo mkfs -t ntfs /dev/sdg1 It will take a while. After it's done, check the file system again with lsblk -f Make sure it shows the file system you just chose and get the UUID sdg \u2514\u2500sdg1 ext4 <uuid>","title":"Formatting the disk"},{"location":"System%20Admin/Disk/format/#mount-the-disk","text":"Create mount point sudo mkdir -p <mountpoint> Update /etc/fstab to mount the disk automatically sudo vi /etc/fstab Add a row like this. The config I use is for ext4 file system. For mounting ntfs or others, refer to fstab UUID=<uuid> <mountpoint> ext4 defaults,noatime 0 0 Verify the mounting fstab will work after reboot so to mount the drive immediately after updating fstab run the following # to mount the specific mountpoint sudo mount <mountpoint> # or, to mount all the mountpoints defined in fstab sudo mount -a","title":"Mount the disk"},{"location":"System%20Admin/Disk/format/#reference","text":"https://phoenixnap.com/kb/linux-format-disk","title":"Reference"},{"location":"System%20Admin/Docker/multiple_compose_files/","text":"How to have load multiple compose file Overview I wanted to split docker-compose.yml into multiple files - 1 service 1 file. So, in the main docker file, I could add/remove by just commenting out 1 line. Solution In version 2, docker has extends feature see reference here . However, this feature was removed in version 3. So I decided to use different approach Loading multiple filesa By default, docker compose will load docker-compose.yml and docker-compose.override.yml for compose files, and load .env for environment variable. Custom file can be specified with -f parameter. docker-compose -f a.yml -f b.yml -f c.yml up The file names here can be specified in COMPOSE_FILE environment variable. For example, COMPOSE_FILE=a.yml:b.yml:c.yml And, since .env will be loaded by docker automatically, I can use this approach to load the service I want like this .env COMPOSE_FILE=docker-compose.yml:service1.yml:service2.yml Reference https://docs.docker.com/compose/reference/envvars/#compose_file","title":"How to have load multiple compose file"},{"location":"System%20Admin/Docker/multiple_compose_files/#how-to-have-load-multiple-compose-file","text":"","title":"How to have load multiple compose file"},{"location":"System%20Admin/Docker/multiple_compose_files/#overview","text":"I wanted to split docker-compose.yml into multiple files - 1 service 1 file. So, in the main docker file, I could add/remove by just commenting out 1 line.","title":"Overview"},{"location":"System%20Admin/Docker/multiple_compose_files/#solution","text":"In version 2, docker has extends feature see reference here . However, this feature was removed in version 3. So I decided to use different approach","title":"Solution"},{"location":"System%20Admin/Docker/multiple_compose_files/#loading-multiple-filesa","text":"By default, docker compose will load docker-compose.yml and docker-compose.override.yml for compose files, and load .env for environment variable. Custom file can be specified with -f parameter. docker-compose -f a.yml -f b.yml -f c.yml up The file names here can be specified in COMPOSE_FILE environment variable. For example, COMPOSE_FILE=a.yml:b.yml:c.yml And, since .env will be loaded by docker automatically, I can use this approach to load the service I want like this .env COMPOSE_FILE=docker-compose.yml:service1.yml:service2.yml","title":"Loading multiple filesa"},{"location":"System%20Admin/Docker/multiple_compose_files/#reference","text":"https://docs.docker.com/compose/reference/envvars/#compose_file","title":"Reference"},{"location":"System%20Admin/Text%20Manipulation/","text":"List of useful CLI","title":"List of useful CLI"},{"location":"System%20Admin/Text%20Manipulation/#list-of-useful-cli","text":"","title":"List of useful CLI"},{"location":"System%20Admin/Text%20Manipulation/cut/","text":"cut Remove sections from each line of files To get specific column $ echo \"1,2,3,4,5\" | cut -d ',' -f 1 -4 1 ,2,3,4 $ echo \"1,2,3,4,5\" | cut -d ',' -f 2 - 2 ,3,4,5 $ echo \"1,2,3,4,5\" | cut -d ',' -f -3 1 ,2,3","title":"cut"},{"location":"System%20Admin/Text%20Manipulation/cut/#cut","text":"Remove sections from each line of files","title":"cut"},{"location":"System%20Admin/Text%20Manipulation/cut/#to-get-specific-column","text":"$ echo \"1,2,3,4,5\" | cut -d ',' -f 1 -4 1 ,2,3,4 $ echo \"1,2,3,4,5\" | cut -d ',' -f 2 - 2 ,3,4,5 $ echo \"1,2,3,4,5\" | cut -d ',' -f -3 1 ,2,3","title":"To get specific column"},{"location":"System%20Admin/Text%20Manipulation/sed/","text":"sed Stream editer for filtering and transforming text To replace simple strings $ echo \"before before before\" | sed 's/before/after/' after before before # with 'g', sed will replace all instances in the lines $ echo \"before before before\" | sed 's/before/after/g' after after after To replace strings with regex $ echo \"string1,ID-123,string2,ID-345\" | sed 's/,ID-[0-9]\\{3\\}//g' string1,string2 Reference 50 sed command examples","title":"sed"},{"location":"System%20Admin/Text%20Manipulation/sed/#sed","text":"Stream editer for filtering and transforming text","title":"sed"},{"location":"System%20Admin/Text%20Manipulation/sed/#to-replace-simple-strings","text":"$ echo \"before before before\" | sed 's/before/after/' after before before # with 'g', sed will replace all instances in the lines $ echo \"before before before\" | sed 's/before/after/g' after after after","title":"To replace simple strings"},{"location":"System%20Admin/Text%20Manipulation/sed/#to-replace-strings-with-regex","text":"$ echo \"string1,ID-123,string2,ID-345\" | sed 's/,ID-[0-9]\\{3\\}//g' string1,string2","title":"To replace strings with regex"},{"location":"System%20Admin/Text%20Manipulation/sed/#reference","text":"50 sed command examples","title":"Reference"},{"location":"System%20Admin/Text%20Manipulation/uniq/","text":"uniq A utility to handle duplicate lines in a file. The input must be sorted before To get unique lines sort file.txt | uniq To get duplicate lines sort file.txt | uniq -d To get duplicate count (unique line will be 1) sort file.txt | uniq -c","title":"uniq"},{"location":"System%20Admin/Text%20Manipulation/uniq/#uniq","text":"A utility to handle duplicate lines in a file. The input must be sorted before","title":"uniq"},{"location":"System%20Admin/Text%20Manipulation/uniq/#to-get-unique-lines","text":"sort file.txt | uniq","title":"To get unique lines"},{"location":"System%20Admin/Text%20Manipulation/uniq/#to-get-duplicate-lines","text":"sort file.txt | uniq -d","title":"To get duplicate lines"},{"location":"System%20Admin/Text%20Manipulation/uniq/#to-get-duplicate-count-unique-line-will-be-1","text":"sort file.txt | uniq -c","title":"To get duplicate count (unique line will be 1)"},{"location":"System%20Admin/selfhosted/MkDocs/","text":"MkDocs Overview mkdocs is static site generator aiming for technical documentation. Installation Prerequisite MkDocs requires python 3 and pip. See installation details here I have python2 installed by default so I install python3 using Homebrew that comes with pip3 brew install python3 Verify python and pip version $ python3 --version Python 3 .9.2 $ pip3 --version pip 21 .0.1 from /usr/local/lib/python3.9/site-packages/pip ( python 3 .9 ) Installing MkDocs pip3 install mkdocs Themes and Plugins Themes mkdocs-material - Material theme for MkDocs Plugins mkdocs-git-revision-date-localized-plugin - Plugin to pull and display git update timestamp on the page Publishing Publish to github pages GitHub Pages provide documentation hosting for free. There are 2 options - Organization/User site and Project site. Organization/User site is to host documentation at .github.io, while Project site is to host documentation at .github.io/ . See https://pages.github.com/ for set up details The easiest way to publish MkDocs website to GitHub Pages in my option is to use GitHub Action . .github/workflows/ci.yml name : ci # Any name as you like on : push : branches : - main # Branch to track jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 with : fetch-depth : 0 # To fetch all history to support mkdocs-git-revision-date-localized-plugin - uses : actions/setup-python@v2 with : python-version : 3.x # Install mkdocs and any themes/plugin here - run : pip install mkdocs - run : pip install mkdocs-material - run : pip install mkdocs-git-revision-date-localized-plugin # Deploy to gh-pages branch - run : mkdocs gh-deploy --force mkdocs gh-deploy is usting github cli behind the scene. It builds the site and call ghp-import to commit to gh-pages branch. So it's important to set pages setting to use gh-pages branch for website. This means the markdown files will be in main branch while the compiled html will be published to github pages via gh-pages branch.","title":"MkDocs"},{"location":"System%20Admin/selfhosted/MkDocs/#mkdocs","text":"","title":"MkDocs"},{"location":"System%20Admin/selfhosted/MkDocs/#overview","text":"mkdocs is static site generator aiming for technical documentation.","title":"Overview"},{"location":"System%20Admin/selfhosted/MkDocs/#installation","text":"","title":"Installation"},{"location":"System%20Admin/selfhosted/MkDocs/#prerequisite","text":"MkDocs requires python 3 and pip. See installation details here I have python2 installed by default so I install python3 using Homebrew that comes with pip3 brew install python3 Verify python and pip version $ python3 --version Python 3 .9.2 $ pip3 --version pip 21 .0.1 from /usr/local/lib/python3.9/site-packages/pip ( python 3 .9 )","title":"Prerequisite"},{"location":"System%20Admin/selfhosted/MkDocs/#installing-mkdocs","text":"pip3 install mkdocs","title":"Installing MkDocs"},{"location":"System%20Admin/selfhosted/MkDocs/#themes-and-plugins","text":"","title":"Themes and Plugins"},{"location":"System%20Admin/selfhosted/MkDocs/#themes","text":"mkdocs-material - Material theme for MkDocs","title":"Themes"},{"location":"System%20Admin/selfhosted/MkDocs/#plugins","text":"mkdocs-git-revision-date-localized-plugin - Plugin to pull and display git update timestamp on the page","title":"Plugins"},{"location":"System%20Admin/selfhosted/MkDocs/#_1","text":"","title":""},{"location":"System%20Admin/selfhosted/MkDocs/#publishing","text":"","title":"Publishing"},{"location":"System%20Admin/selfhosted/MkDocs/#publish-to-github-pages","text":"GitHub Pages provide documentation hosting for free. There are 2 options - Organization/User site and Project site. Organization/User site is to host documentation at .github.io, while Project site is to host documentation at .github.io/ . See https://pages.github.com/ for set up details The easiest way to publish MkDocs website to GitHub Pages in my option is to use GitHub Action . .github/workflows/ci.yml name : ci # Any name as you like on : push : branches : - main # Branch to track jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 with : fetch-depth : 0 # To fetch all history to support mkdocs-git-revision-date-localized-plugin - uses : actions/setup-python@v2 with : python-version : 3.x # Install mkdocs and any themes/plugin here - run : pip install mkdocs - run : pip install mkdocs-material - run : pip install mkdocs-git-revision-date-localized-plugin # Deploy to gh-pages branch - run : mkdocs gh-deploy --force mkdocs gh-deploy is usting github cli behind the scene. It builds the site and call ghp-import to commit to gh-pages branch. So it's important to set pages setting to use gh-pages branch for website. This means the markdown files will be in main branch while the compiled html will be published to github pages via gh-pages branch.","title":"Publish to github pages"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-awesome-pages-plugin/","text":"mkdocs-awesome-pages-plugin Overview MkDocs has nav configuration in mkdocs.yml to set up navigation of the page. If it's not provided, the navigation will be automatically created by all markdown files in the document directory. We need to use one, not both. And, the auto create will be sorted alphabetically, which is not flexible. This plugin allows us to have more control. Installation Install the plugin with pip pip install mkdocs-awesome-pages-plugin Enable the plugin in mkdocs.yml mkdocs.yml plugins : - search - awesome-pages Configuration Rest ... is a special entry to let MkDocs to add the rest from the folder structure nav : - introduction.md - ... - summary.md","title":"mkdocs-awesome-pages-plugin"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-awesome-pages-plugin/#mkdocs-awesome-pages-plugin","text":"","title":"mkdocs-awesome-pages-plugin"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-awesome-pages-plugin/#overview","text":"MkDocs has nav configuration in mkdocs.yml to set up navigation of the page. If it's not provided, the navigation will be automatically created by all markdown files in the document directory. We need to use one, not both. And, the auto create will be sorted alphabetically, which is not flexible. This plugin allows us to have more control.","title":"Overview"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-awesome-pages-plugin/#installation","text":"Install the plugin with pip pip install mkdocs-awesome-pages-plugin Enable the plugin in mkdocs.yml mkdocs.yml plugins : - search - awesome-pages","title":"Installation"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-awesome-pages-plugin/#configuration","text":"","title":"Configuration"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-awesome-pages-plugin/#rest","text":"... is a special entry to let MkDocs to add the rest from the folder structure nav : - introduction.md - ... - summary.md","title":"Rest"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/","text":"mkdocs-git-revision-date-localized-plugin Overview mkdocs-git-revision-date-localized-plugin is MkDocs plugin to add a last updated date to MkDocs pages. This is a fork of mkdocs-git-revision-date-plugin See the doc at https://timvink.github.io/mkdocs-git-revision-date-localized-plugin/ Installation Installing plugin pip install mkdocs-git-revision-date-localized-plugin Configuring MkDocs mkdocs.yml plugins : - search - git-revision-date-localized Optional Configuring github action .github/workflows/ci.yaml - uses : actions/checkout@v2 with : fetch-depth : 0 Usage With support theme like mkdocs-material , the last update value will be displayed at the end of the page automatically. Page can add creation time or last update time using variables git_creation_date_localized and git_revision_date_localized Custom create date = 2021-12-18 14:35:12 Custom update date = 2021-12-18 14:35:12 Configuration See plugin's option page for details mkdocs.yml plugins : - git-revision-date-localized : type : timeago timezone : Europe/Amsterdam locale : en fallback_to_build_date : false enable_creation_date : true exclude : - index.md enabled : true","title":"mkdocs-git-revision-date-localized-plugin"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#mkdocs-git-revision-date-localized-plugin","text":"","title":"mkdocs-git-revision-date-localized-plugin"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#overview","text":"mkdocs-git-revision-date-localized-plugin is MkDocs plugin to add a last updated date to MkDocs pages. This is a fork of mkdocs-git-revision-date-plugin See the doc at https://timvink.github.io/mkdocs-git-revision-date-localized-plugin/","title":"Overview"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#installation","text":"","title":"Installation"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#installing-plugin","text":"pip install mkdocs-git-revision-date-localized-plugin","title":"Installing plugin"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#configuring-mkdocs","text":"mkdocs.yml plugins : - search - git-revision-date-localized","title":"Configuring MkDocs"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#optional","text":"","title":"Optional"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#configuring-github-action","text":".github/workflows/ci.yaml - uses : actions/checkout@v2 with : fetch-depth : 0","title":"Configuring github action"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#usage","text":"With support theme like mkdocs-material , the last update value will be displayed at the end of the page automatically. Page can add creation time or last update time using variables git_creation_date_localized and git_revision_date_localized Custom create date = 2021-12-18 14:35:12 Custom update date = 2021-12-18 14:35:12","title":"Usage"},{"location":"System%20Admin/selfhosted/MkDocs/plugins/mkdocs-git-revision-date-localized-plugin/#configuration","text":"See plugin's option page for details mkdocs.yml plugins : - git-revision-date-localized : type : timeago timezone : Europe/Amsterdam locale : en fallback_to_build_date : false enable_creation_date : true exclude : - index.md enabled : true","title":"Configuration"},{"location":"System%20Admin/selfhosted/MkDocs/themes/mkdocs-material/","text":"mkdocs-material Overview Material for MkDocs (mkdocs-material) is a theme for MkDocs. Installation Install theme via pip pip install mkdocs-material Configuration Syntax Highlighting MkDocs provides 2 ways to set up syntax highlighting - during building using Pygments or during runtime using JavaScript. Here is how to set up with Pygments i.e. build time highlighting. See reference for code blocks here mkdocs.yml markdown_extensions : - pymdownx.highlight : anchor_linenums : true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences","title":"mkdocs-material"},{"location":"System%20Admin/selfhosted/MkDocs/themes/mkdocs-material/#mkdocs-material","text":"","title":"mkdocs-material"},{"location":"System%20Admin/selfhosted/MkDocs/themes/mkdocs-material/#overview","text":"Material for MkDocs (mkdocs-material) is a theme for MkDocs.","title":"Overview"},{"location":"System%20Admin/selfhosted/MkDocs/themes/mkdocs-material/#installation","text":"Install theme via pip pip install mkdocs-material","title":"Installation"},{"location":"System%20Admin/selfhosted/MkDocs/themes/mkdocs-material/#configuration","text":"","title":"Configuration"},{"location":"System%20Admin/selfhosted/MkDocs/themes/mkdocs-material/#syntax-highlighting","text":"MkDocs provides 2 ways to set up syntax highlighting - during building using Pygments or during runtime using JavaScript. Here is how to set up with Pygments i.e. build time highlighting. See reference for code blocks here mkdocs.yml markdown_extensions : - pymdownx.highlight : anchor_linenums : true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences","title":"Syntax Highlighting"},{"location":"System%20Admin/selfhosted/samba/","text":"Samba Configuration To allow samba to follow symlinks # Global allow insecure wide links = yes # Profile follow symlinks = yes wide links = yes To allow older version of samba client to connect server min protocol = NT1 Administration To add samba user Add user linux user account first sudo useradd john sudo passwd john Add Samba user sudo smbpasswd -a john To modify existing user sudo smbpasswd john To restart samba server sudo service smbd restart To add existing user to a group sudo usermod -a -G <group> <user> To add a new group sudo groupadd mynewgroup","title":"Samba"},{"location":"System%20Admin/selfhosted/samba/#samba","text":"","title":"Samba"},{"location":"System%20Admin/selfhosted/samba/#configuration","text":"To allow samba to follow symlinks # Global allow insecure wide links = yes # Profile follow symlinks = yes wide links = yes To allow older version of samba client to connect server min protocol = NT1","title":"Configuration"},{"location":"System%20Admin/selfhosted/samba/#administration","text":"To add samba user Add user linux user account first sudo useradd john sudo passwd john Add Samba user sudo smbpasswd -a john To modify existing user sudo smbpasswd john To restart samba server sudo service smbd restart To add existing user to a group sudo usermod -a -G <group> <user> To add a new group sudo groupadd mynewgroup","title":"Administration"}]}