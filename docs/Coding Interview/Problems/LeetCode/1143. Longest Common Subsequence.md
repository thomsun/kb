## Problem
Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

    For example, "ace" is a subsequence of "abcde".

A common subsequence of two strings is a subsequence that is common to both strings.

 

Example 1:
```
Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
```
Example 2:
```
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
```
Example 3:
```
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
```
 

Constraints:
```
    1 <= text1.length, text2.length <= 1000
    text1 and text2 consist of only lowercase English characters.
```

## Approaches
- Intuitively, we can have 2 pointers - `i` for text1 and `j` for text2 - that we can go through each char of both text
- For each `i` and `j`,
  - if `text1[i]` == `text2[j]` then the sequence increase by 1 i.e. `dp[i][j]` = `dp[i-1][j-1] + 1`
  - they are not equal then the max sequence at `i` and `j` is max of `dp[i-1][j]` + `dp[][j-1]`
- From the equation above, `dp[i][j]` requires previous 3 - UP, LEFT, and UP-LEFT
```
dp array

      j 0 1 2 3 4 ...
    i 0 A B       ...          
      1 C X
      2   
      3 
      4 
     ...
```
- From example above, X is calculated from `A`, `B`, and `C`
- If we start from `dp[0][0]` for the first char of both texts, we will need special check when it hit boundary
- We could add additional row/col and start first char of both texts at `dp[1][1]` instead to avoid special case like this
```
dp array

      j 0 1 2 3 4 ... text2.length()
      0 0 0 0 0 0 ...       .   
      1 0 . . . .           .
      2 0 . . . .           . 
    i 3 0 . . . .           .
      4 0 . . . .           .
     ...
text1.length()              X

X, which is the answer, is at dp[text1.length()][text2.length()]
```

## Solution
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int dp[][] = new int[text1.length()+1][text2.length()+1];

        for (int i=0; i<text1.length(); i++) {
            for (int j=0; j<text2.length(); j++) {
                if (text1.charAt(i) == text2.charAt(j)) {
                    dp[i+1][j+1] = dp[i][j] + 1;
                } else {
                    dp[i+1][j+1] = Math.max(dp[i][j+1], dp[i+1][j]);
                }
            }
        } 
        return dp[text1.length()][text2.length()];
    }
}
```